@ngdoc overview
@name Developer Guide: Модульное тестирование
@description

JavaScript – это динамически типизированный язык, который может выполнять любые выражения, но при этом 
его компилятор практически не помогает в разработке. По этой причине код, написанный на JavaScript, должен пройти 
через серию тестов. В Angular есть множество функций, которые облегчают тестирование приложений. Так что нет причин 
для того чтобы не тестировать ваши приложения.

# Всё о том, как не смешивать проблемы

Модульное тестирование предназначено для тестирования блоков кода, как следует из его названия. Модульные тесты 
пытаются задавать вопросы, такие как «Корректно ли работает данный блок кода?» или «Идет ли сортировка в 
правильном порядке?»

Для ответа на эти вопросы, очень важно иметь возможность изолировать блок кода в тесте. Потому что во время 
тестирования функции сортировки, не нужно учитывать другие детали, такие как элементы DOM или производить любые 
манипуляции с XHR для получения данных.

Хотя это кажется очевидным, обычно бывает трудно вызывать отдельные функции в типичном объекте. Проблема в том, 
что разработчики часто смешивают все в одно куске кода, который делает все. Он читает данные с помощью XHR, 
сортирует их, а затем манипулирует DOM.

В Angular мы попытались сделать тестирование легким, для чего представили внедрение зависимостей для XHR 
(который можно имитировать) и создали абстракции, которые позволяют сортировать модель без необходимости 
прибегать к манипуляции с DOM. В итоге легко написать функцию сортировки некоторых данных 
и при этом тест может создать эти данные, применить функцию, и проверить что результирующая модель отсортировна верно. 
Тест не ждет XHR или создает правильный вид DOM, или утверждет что ваша функция изменила DOM как надо.

## Больше возможностей — больше ответственности

Angular писался с учетом потребностей тестирования, но все же требуется чтобы и вы делали все верно. Мы попытались 
облегчить работу, и если вы будете делать все правильно, то, в итоге, получите легко тестируемое приложение.

## Внедрение зависимости
Существуют несколько способов внедрения зависимости:
1. Можно создать ее с помощью оператора new.
2. Можно найти ее в известном месте, например в глобальном объекте. 
3. Можно запросить ее у реестра (известного как сервис реестра, но как получть доступ к этому сервису. 
Скорее всего это вариант 2). 
4. Можно попросить передать ее вам.

Из четырех вариантов, только последний является тестируемым. Давайте посмотрим почему:

### Использование оператора `new`

Хотя нет ничего плохого, в применении оператора `new` принципиальным является вопрос, что вызывая его каждый раз, 
вы привязываете вызов функции к типу. Например, можно сказать, что каждый раз когда мы хотим получить данные 
с сервера, мы создаем экземпляр `XHR`.

<pre>
function MyClass() {
  this.doWork = function() {
    var xhr = new XHR();
    xhr.open(method, url, true);
    xhr.onreadystatechange = function() {...}
    xhr.send();
  }
}
</pre>

Этот вопрос встает при тестировании, мы очень хотели бы создать экземпляр `MockXHR` который позволит использовать 
нужные нам данные или имитировать сбой сети. Путем создания `new XHR()` мы постоянно связанны с фактическим XHR, 
и нет хорошего способа заменить его. Да, можно пойти окольными путями, но это плохая идея по многим причинам, 
которые выходят за рамки данного документа.

Класс выше трудно протетстировать, поэтому нужно использовать обходные пути:
<pre>
var oldXHR = XHR;
XHR = function MockXHR() {};
var myClass = new MyClass();
myClass.doWork();
// утверждаем, что MockXHR вызван с верными аргументами
XHR = oldXHR; // если забыть об этом, могут произойти неприятные вещи
</pre>


### Глобальный просмотр:
Другой вариант решения проблемы это просмотр сервисов, расположение которых уже известно.

<pre>
function MyClass() {
  this.doWork = function() {
    global.xhr({
      method:'...',
      url:'...',
      complete:function(response){ ... }
    })
  }
}
</pre>

Хотя создается новый экземпляр зависимости, это восновном то же, что и создание нового с помощью `new`, так как 
нет хорошего способа для перехвата вызова `global.xhr` в целях тестирования, опять придется что то придумывать. 
Основной вопрос при тестировании в том, что глобальную переменную нужно изменить для того чтобы заменить ее макетом. 
Чтобыузнать, почему это плохо, смотрите : {@link
http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/ Brittle Global
State & Singletons}

Класс выше трудно тестировать, так как необходимо изменить глобальное состояние:
<pre>
var oldXHR = global.xhr;
global.xhr = function mockXHR() {};
var myClass = new MyClass();
myClass.doWork();
// утверждаем, что MockXHR вызван с верными аргументами
global.xhr = oldXHR; // если забыть об этом, могут произойти неприятные вещи
</pre>


### Реестр сервисов:

Как может показаться, проблема может быть решена путем ведения реестра для всех сервисов, а затем в тестах 
заменять ими сервисы при необходимости.

<pre>
function MyClass() {
  var serviceRegistry = ????;
  this.doWork = function() {
    var xhr = serviceRegistry.get('xhr');
    xhr({
      method:'...',
      url:'...',
      complete:function(response){ ... }
    })
}
</pre>

Однако, откуда взять serviceRegistry? Если это: 
* новый `new` объект, тогда тест не имеет никакой возможности сбросить сервисы тестирования 
* глобальный просмотр, то также возвращается глобальный сервис (но произвести сброс легче, так как есть только 
одна глобальная переменная для сброса).

Класс выше трудно проверить, поскольку необходимо изменить глобальное состояние:
<pre>
var oldServiceLocator = global.serviceLocator;
global.serviceLocator.set('xhr', function mockXHR() {});
var myClass = new MyClass();
myClass.doWork();
// утверждаем, что MockXHR вызван с верными аргументами
global.serviceLocator = oldServiceLocator; // если забыть об этом, могут произойти неприятные вещи
</pre>


### Передача зависимости:
В конце концов, зависимость может быть передана в метод.

<pre>
function MyClass(xhr) {
  this.doWork = function() {
    xhr({
      method:'...',
      url:'...',
      complete:function(response){ ... }
    })
}
</pre>

Это предпочтительный способ, так как код не делает ни каких предположений о том, что за объект `xhr` пришел, 
кто его создал и передал внутрь. Так как его создает другой код, а не использующий его класс, он отделяет 
ответсвтенность создания от логики; это и есть внедрение зависимости в двух словах.

Класс выше легко тестируется, поскольку млжно написать:
<pre>
function xhrMock(args) {...}
var myClass = new MyClass(xhrMock);
myClass.doWork();
// утверждаем, что MockXHR вызван с верными аргументами
</pre>

Заметьте, что глобальные переменные не изменялись при написании этого теста.

Angular поставляется с {@link di внедрением зависимости} и в результате делать правильные вещи становится легче, 
но все же их нужно делать.

## Контроллеры
В любом приложении уникальным является то что оно делает, т.е. логика, вот ее мы и хотим протестировать. 
Если логика вашего приложения содержит манипуляции с DOM, его будет трудно протестировать, это показано ниже:

<pre>
function PasswordCtrl() {
  // получение ссылок на элементы DOM
  var msg = $('.ex1 span');
  var input = $('.ex1 input');
  var strength;

  this.grade = function() {
    msg.removeClass(strength);
    var pwd = input.val();
    password.text(pwd);
    if (pwd.length > 8) {
      strength = 'strong';
    } else if (pwd.length > 3) {
      strength = 'medium';
    } else {
      strength = 'weak';
    }
    msg
     .addClass(strength)
     .text(strength);
  }
}
</pre>

Приведенный выше код является проблемным с точки зрения пригодности для тестирования, так как тесту требуется 
иметь правильное представление DOM, перед тем, как выполнить тест. Тест может выглядеть следующим образом:

<pre>
var input = $('<input type="text"/>');
var span = $('<span>');
$('body').html('<div class="ex1">')
  .find('div')
    .append(input)
    .append(span);
var pc = new PasswordCtrl();
input.val('abc');
pc.grade();
expect(span.text()).toEqual('weak');
$('body').html('');
</pre>

В контроллерах Angular логика строго отделяется от манипуляций с DOM, что в итоге делает их более пригодными для 
тестирования, что видно на примере ниже:

<pre>
function PasswordCtrl($scope) {
  $scope.password = '';
  $scope.grade = function() {
    var size = $scope.password.length;
    if (size > 8) {
      $scope.strength = 'strong';
    } else if (size > 3) {
      $scope.strength = 'medium';
    } else {
      $scope.strength = 'weak';
    }
  };
}
</pre>

и в тесте далее

<pre>
var pc = new PasswordCtrl();
pc.password('abc');
pc.grade();
expect(pc.strength).toEqual('weak');
</pre>

Обратите внимание, что тест не только намного короче, но и легче для понимания что происходит. 
Мы говорим, что тест рассказывает историю, а затем проверяет случайные свойства, которые не связаны между собой.

## Фильтры
{@link api/ng.$filter Фильтры} это функции, которые преобразуют данные в требуемый формат для чтения пользователем. 
Они важны, поскольку освобождают логику приложения от необходимости форматирования данных, что упрощает её ещё больше.

<pre>
myModule.filter('length', function() {
  return function(text){
    return (''+(text||'')).length;
  }
});

var length = $filter('length');
expect(length(null)).toEqual(0);
expect(length('abc')).toEqual(3);
</pre>

## Директивы
Директивы в Angular отвечают за инкапсуляцию комплексной функциональности внутри пользовательского тега HTML,
атрибута, класса или комментария. Модульные тесты очень важны для директив, поскольку компоненты, которые вы создаете 
с помощью директив, могут быть использованы во всем приложении и во многих различных контекстах.

### Простая директива HTML

Давайте начнем с определение зависимости в приложении.

<pre>
var app = angular.module('myApp', []);
</pre>

Сейчас можно добавить директиву в приложение.

<pre>
app.directive('aGreatEye', function () {
    return {
        restrict: 'E',
        replace:  true,
        template: '<h1>lidless, wreathed in flame</h1>'
    };
});
</pre>

Эта директива использует тег `<a-great-eye></a-great-eye>`. Она заменяет входной тег на шаблон 
`<h1>lidless, wreathed in flame</h1>`. Теперь напишем модульный тест на jasmine для тестирования функциональности.

<pre>
describe('Unit testing great quotes', function() {
    var $compile;
    var $rootScope;

    // Загрузка модуля myApp, содержащего директиву
    beforeEach(module('myApp'));

    // Храним ссылки в $rootScope и $compile
    // чтобы они были доступны для всех тестов, описанных в этом блоке
    beforeEach(inject(function(_$compile_, _$rootScope_){
      // При сопоставлении инжектор заменяет подчеркивание (_) вокруг имен параметров when matching
      $compile = _$compile_;
      $rootScope = _$rootScope_;
    }));
    
    it('Replaces the element with the appropriate content', function() {
        // Компиляция части HTML, содержащей директиву
        var element = $compile("<a-great-eye></a-great-eye>")($rootScope);
        // Убедитесь, что скомпилированный элемент содержит содержимое шаблонов
        expect(element.html()).toContain("lidless, wreathed in flame");
    });
});
</pre>

Мы внедрили службы $compile и $rootScope перед каждым тестом jasmine. Сервис $compile используется для отображения 
директивы aGreatEye. После визуализации директивы проверяется что директива заменила свое содержимое на «lidless, 
wreathed in flame».

## Mocks
Оу

## Изоляция глобального состояния
Оу

# Предпочтительный способ тестирования
ну

## JavaScriptTestDriver
ну

## Jasmine
ну

## Простой проект
оу
