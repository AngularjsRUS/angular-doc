@ngdoc overview
@name Директивы
@description

Директивы описывают изменение поведения или преобразование DOM модели,
связанное с пользовательским атрибутом, именем элемента, или css классом.
Директивы позволяют расширить HTML синтаксис в декларативной форме.

Angular поставляется с набором директив, полезных для создания веб-приложений,
но может быть расширен так, чтобы превратить HTML в декларативный предметно-ориентированный язык (DSL).

# Вызов директив из HTML

Директивы при создании всегда именуются в нижнеВерблюжьемРегистре (camelCase нотация), например: `ngBind`.
Для того чтобы использовать директиву необходимо перевести ее в нижний регистр с использованием 
специальных символов `:`, `-`, или `_` в качестве разделителя (snake_case нотация). 
Для получения валидного кода, при вызове директивы можно использовать префиксы `x-`, или `data-`.
Примеры: `ng:bind`, `ng-bind`, `ng_bind`, `x-ng-bind` и `data-ng-bind`.

Директивы могут размещаться в именах элементов, атрибутах, именах классов, а также в комментариях. Ниже 
примеры эквивалентных вызовов директивы `myDir`. (Тем не менее, большинство директив ограничены только атрибутами.)

<pre>
  <span my-dir="exp"></span>
  <span class="my-dir: exp;"></span>
  <my-dir></my-dir>
  <!-- directive: my-dir exp -->
</pre>

Директивы могут вызываться различными способами, но, в конечном счете,
это будет эквивалентно тому, что показано в следующем примере.

<doc:example>
  <doc:source >
   <script>
     function Ctrl1($scope) {
       $scope.name = 'angular';
     }
   </script>
   <div ng-controller="Ctrl1">
     Hello <input ng-model='name'> <hr/>
     &lt;span ng:bind="name"&gt; <span ng:bind="name"></span> <br/>
     &lt;span ng_bind="name"&gt; <span ng_bind="name"></span> <br/>
     &lt;span ng-bind="name"&gt; <span ng-bind="name"></span> <br/>
     &lt;span data-ng-bind="name"&gt; <span data-ng-bind="name"></span> <br/>
     &lt;span x-ng-bind="name"&gt; <span x-ng-bind="name"></span> <br/>
   </div>
  </doc:source>
  <doc:scenario>
    it('should show off bindings', function() {
      expect(element('div[ng-controller="Ctrl1"] span[ng-bind]').text()).toBe('angular');
    });
  </doc:scenario>
</doc:example>

# Обработка строк (связывание текста и атрибутов)

Во время компиляции {@link api/ng.$compile компилятор} сканирует текст и атрибуты,
используя сервис {@link api/ng.$interpolate $interpolate} для того чтобы узнать,
содержат ли они встроенные выражения.
Эти выражения регистрируются как {@link api/ng.$rootScope.Scope#$watch наблюдаемые} и
будут обновлены в цикле {@link api/ng.$rootScope.Scope#$digest digest}.
Пример обработки строк:

<pre>
<a href="img/{{username}}.jpg">Hello {{username}}!</a>
</pre>


# Связывание атрибута ngAttr

Если связанный атрибут имеет префикс `ngAttr` (денормализованный вид: 'ng-attr-',
'ng:attr-'), то во время компиляции префикс будет удален, и
связывание применится как к атрибуту без префикса.
Это обеспечивает связывание с атрибутами, которые иначе некорректно
обрабатываются браузерами в неоткомпилированной
форме (например, `img[src]` или svg's `circle[cx]` атрибуты).

Рассмотрим на примере:

    <svg>
      <circle ng-attr-cx="{{cx}}"></circle>
    </svg>

где модель `cx` устанавливается в 5, и результатом рендеринга будет dom:

    <svg>
      <circle cx="5"></circle>
    </svg>

Если была применена связь `{{cx}}` непосредственно к установленному атрибуту `cx`,
вы получите следующее сообщение об ошибке:
`Error: Invalid value for attribute cx="{{cx}}"`. С `ng-attr-cx` можно обойти эту проблему.


# Компиляция и сканирование директив

Компиляция HTML разделяется на три фазы:

  1. Сначала HTML преобразуется в DOM-структуру, с помощью стандартного API браузера.
  Важно понимать это, потому что шаблоны должны представлять интерпретируемый HTML,
  в отличие от шаблонов большинства шаблонизаторов, работающих со строками, а не с DOM-элементами.

  2. Компиляция DOM производится вызовом метода {@link api/ng.$compile $compile()}.
  Метод обходит DOM и ищет директивы. Если директива найдена, она будет добавлена
  в список директив, связанных с данным элементом DOM. После того как все директивы
  для данного элемента DOM были выявлены они сортируются по приоритету и запускаются
  функции их компиляции `compile()`. Функция компиляции директивы может изменить структуру
  DOM и отвечает за передачу функции `link()` дальнейших указаний.
  Метод {@link api/ng.$compile $compile()} возвращает
  комбинированную связующую функцию, которая представляет собой коллекцию всех
  связующих функций (link), возвращенных каждой функцией компиляции каждой директивы.

  3. Привязка шаблона к области видимости (scope) осуществляется
  с помощью вызова связывающей функции, возвращенной из предыдущего шага.
  Это в свою очередь вызовет связующие функции отдельных директив, разрешит
  им установить {@link api/ng.$rootScope.Scope#$watch наблюдателей} на элементы
  и начать наблюдение за {@link api/ng.$rootScope.Scope областью видимости}.
  В результате образуется динамическая связь между областями видимости и DOM. Изменение
  в области видимости отражается в DOM.

<pre>
  var $compile = ...; // внедрен в код
  var scope = ...;

  var html = '<div ng-bind="exp"></div>';

  // Шаг 1: преобразование HTML в DOM-элемент
  var template = angular.element(html);

  // Шаг 2: компиляция шаблона
  var linkFn = $compile(template);

  // Шаг 3: связывание скомпилированного шаблона с областью.
  linkFn(scope);
</pre>

## Причины разделения стадии компиляции и связывания

Дочитав до этого раздела можно удивиться,
зачем разделять процесс на компиляцию и связывание.
Для понимания этого давайте посмотрим на реальный пример с репитером (repeater):

<pre>
  Hello {{user}}, you have these actions:
  <ul>
    <li ng-repeat="action in user.actions">
      {{action.description}}
    </li>
  </ul>
</pre>

Кратко: функции компиляции и связывания разделены потому что
в любой момент изменение модели приводит к изменению в DOM структуре, в данном случае - репитера.

Когда предыдущий пример компилируется, компилятор обходит каждый узел DOM в поиске директив. Элемент `{{user}}` - пример директивы {@link api/ng.$interpolate вычисления} выражений, а {@link api/ng.directive:ngRepeat ngRepeat} - пример другой директивы. Но при обработке директивы {@link api/ng.directive:ngRepeat ngRepeat} возникает дилемма. Она должна как можно быстрее создавать новые элементы списка `<li>` для каждого элемента `action` в `user.actions`. Это означает, что она должна сохранять «чистую» копию элемента `<li>` для дальнейшего клонирования, и как только вставляется новый элемент `action`, эта копия шаблона должна быть клонирована и вставлена в список `<ul>`. Но клонирования элемента `<li>` недостаточно. Также необходима его компиляция для того, чтобы такие директивы как `{{action.descriptions}}` были вычислены в правильной {@link api/ng.$rootScope.Scope области видимости}. Простейшим методом в данном случае была бы простая вставка копии элемента `<li>` и последующей его компиляции. Но компиляция каждого клонированного элемента была бы слишком медленной, поскольку компиляция требует, чтобы мы обошли все DOM-дерево для поиска и выполнения директив. Если делать компиляцию внутри репитера, который должен возвратить 100 элементов, то это быстро привело бы к проблемам с производительностью.

Решение проблемы — разделить процесс компиляции на две фазы — непосредственно саму компиляцию, при которой все директивы определяются и сортируются по приоритетам, и фазу связывания, которая связывает экземпляр конкретной {@link api/ng.$rootScope.Scope области видимости} и конкретный экземпляр элемента `<li>`.

{@link api/ng.directive:ngRepeat ngRepeat} предотвращает компиляцию по иерархии элемента `<li>`. Вместо этого директива ngRepeat компилирует `<li>` отдельно. Результатом компиляции элемента `<li>` является связующая функция, которая содержит все указания, содержащиеся в элементе `<li>`, и готовая к прикреплению к конкретному клону элемента `<li>`. Во время выполнения, {@link api/ng.directive:ngRepeat ngRepeat} следит за выражением и за тем как элементы добавляются в массив клонов элемента `<li>`, создает новые возможности для клонированных элементов `<li>` и вызывает связующую функцию для клонированного `<li>`.

Резюме:

  * *функция компиляции* - функция компиляции встречается в директивах относительно редко, так как большинство директив работают с конкретным экземпляром элемента DOM, а не с преобразованием шаблона DOM-элемента. Любые операции, которые могут быть распределены между экземплярами директив должны быть перенесены в функцию компиляции для повышения производительности.

  * *функция линковки* - директивы редко обходятся без функции линковки, которая позволяет директиве регистрировать наблюдателей для конкретных экземляров клонированных DOM-элементов, а также копировать содержимое в DOM из области видимости.


# Запись директив (упрощенно)

В этом примере описывается директива, выводящая текущее время.

<doc:example module="time">
  <doc:source>
   <script>
     function Ctrl2($scope) {
       $scope.format = 'M/d/yy h:mm:ss a';
     }

     angular.module('time', [])
       // Регистрируем фабричный метод для директивы 'myCurrentTime'.
       // Внедряем $timeout и сервис dateFilter пока фабричный метод DI.
       .directive('myCurrentTime', function($timeout, dateFilter) {
         // возвращаем функцию линковки директивы. (компилировать функцию не нужно)
         return function(scope, element, attrs) {
           var format,  // формат даты
               timeoutId; // timeoutId, так что мы можем останавливать обновление времени

           // используя обновление UI
           function updateTime() {
             element.text(dateFilter(new Date(), format));
           }

           // проверка выражения и обновление UI при изменении.
           scope.$watch(attrs.myCurrentTime, function(value) {
             format = value;
             updateTime();
           });

           // расписание обновлений за секунду
           function updateLater() {
             // сохраняем timeoutId для отмены
             timeoutId = $timeout(function() {
               updateTime(); // обновляем DOM
               updateLater(); // расписание других обновлений
             }, 1000);
           }

           // прослушиваем разрушающее (removal) DOM событие, и отменяем следующее обновление UI
           // для предотвращения обновления времени после того как DOM-элемент был удален.
           element.bind('$destroy', function() {
             $timeout.cancel(timeoutId);
           });

           updateLater(); // убиваем процесс обновления UI.
         }
       });
   </script>
   <div ng-controller="Ctrl2">
     Date format: <input ng-model="format"> <hr/>
     Current time is: <span my-current-time="format"></span>
   </div>
  </doc:source>
</doc:example>


# Запись директив (расширенная)

Существуют различные способы объявления директивы. Различие заключается в значении возвращаемом фабричной функцией. Можно либо возвращать Объект Определения Директивы (см. ниже), который определяет свойства директивы, или только функцию postLink такого объекта (все другие свойства будут иметь значения по умолчанию).

Ниже пример директивы, объявленной с помощью Объекта Определения Директивы:

<pre>
  var myModule = angular.module(...);

  myModule.directive('directiveName', function factory(injectables) {
    var directiveDefinitionObject = {
      priority: 0,
      template: '<div></div>',
      templateUrl: 'directive.html',
      replace: false,
      transclude: false,
      restrict: 'A',
      scope: false,
      compile: function compile(tElement, tAttrs, transclude) {
        return {
          pre: function preLink(scope, iElement, iAttrs, controller) { ... },
          post: function postLink(scope, iElement, iAttrs, controller) { ... }
        }
      },
      link: function postLink(scope, iElement, iAttrs) { ... }
    };
    return directiveDefinitionObject;
  });
</pre>

В большинстве случаев столь тонкий контроль, как показано выше, не нужен и все это можно упростить. Все еще можно вернуть Объект Определения Директивы, но только установка «compile» выполняет свойства Объекта, и положиться на значения по умолчанию для остальных свойств.

Поэтому приведенное выше может быть упрощено:

<pre>
  var myModule = angular.module(...);

  myModule.directive('directiveName', function factory(injectables) {
    var directiveDefinitionObject = {
      compile: function compile(tElement, tAttrs) {
        return function postLink(scope, iElement, iAttrs) { ... }
      }
    };
    return directiveDefinitionObject;
  });
</pre>

Наконец, большинство директив затрагивают себя только с создания экземпляров, а не с шаблонов преобразований, позволяя дальнейшее упрощение.

Здесь мы только определим функцию postLink:

<pre>
  var myModule = angular.module(...);

  myModule.directive('directiveName', function factory(injectables) {
    return function postLink(scope, iElement, iAttrs) { ... }
  });
</pre>


## Фабричный метод

Фабричный метод отвечает за создание директивы. Он вызывается только один раз, когда {@link api/ng.$compile компилятор} впервые находит директиву. В нем можно выполнить инициализацию. Этот метод вызывается с помощью {@link
api/AUTO.$injector#invoke $injector.invoke} который делает его инъекционным с соблюдением всех правил инъекционной аннотации.

## Директива Определения Объекта (Directive Definition Object)

В объекте определения директивы содержатся инструкции для {@link api/ng.$compile компилятора}. Атрибуты:

  * `name` - имя текущей области. Опционально и по умолчанию имя при регистрации.

  * `priority` - когда на одном DOM-элементе определены несколько директив, иногда бывает необходимо указать
    порядок, в их выполнения. Приоритет используется для сортировки директив перед вызовом их функций компиляции.
    Первой выполняется директива с самым высоким приоритетом. Порядок выполнения директив с одинаковым приоритетом 
    в рамках одной задачи неопределен.

  * `terminal` - если установлен в true, то приоритетным будет последний набор директив, которые будут выполняться 
    (любые указания для текущего приоритета будут по-прежнему выполняться в порядке приоритета, если он определен).
    Другими словами, терминальная директива всегда выполняется последней. Если на элементе были определены другие
    директивы с более низким приоритетом, то они не выполнятся.

  * `scope` - если установлено:

    * `true` - то новая область будет создана для этой директивы. Если несколько директив на тех же элементах запрашивают новую область, только одна область будет создана. Новое область не распространяется на корневой шаблон, так как корневой шаблон, всегда получает новую область.
    * `{}` (хэш-объект) - будет создана новая «изолированная» область. «Изолированная» область отличается от обычной тем, что она не прототипически унаследована от родительской области. Это полезно при создании повторно используемых компонентов, которые не должны случайно прочитать или изменить данные в родительской области.<br/>
     «Изолированная» область принимает хэш-объект который устанавливает свойства локальной области, полученные из родительской области. Эти локальные свойства полезны для сглаживания значений для шаблонов. Локальные установки являются хэшем свойств локальной области своего источника:

      * `@` или `@attr` - связывает свойства локальной области со значением атрибута в DOM. Результат всегда является строкой с DOM-атрибутами являющимися так же строками. Если имя атрибута `attr` не указано, то оно предполагается таким же как локальное имя. Если учитывается `<widget my-attr="hello {{name}}">` и виджет определения области: `{LocalName:'@myAttr'}`, то виджет области со свойством `LocalName` будет отражать интерполированное значение `hello, {{Имя}}`. При изменении имени атрибута свойство `LocalName` будет в виджете области. `name` читается из родительской области (не из области компонента).

      * `=` или `=attr` - создает двунаправленную связь между свойством локальной области и свойством родительской области, имя которого определено с помощью атрибута `attr`. Если имя `attr` не указано, то оно предполагается таким же, как локальное имя. Если учитывается `<widget my-attr="parentModel">` и виджет определения области: `{LocalModel:'=myAttr'}`, то виджет области со свойством `LocalModel` будет отражать значение `parentModel` из родительской области. Любые изменения в `parentModel` будут отражены в `LocalModel` и любые изменения в `LocalModel` будут отражать в `parentModel`.

      * `&` или `&attr` - обеспечивает способ выполнения выражение в контексте родительской области. Если имя `attr` не указано, то оно предполагается таким же, как локальное имя. Если учитывается `<widget my-attr="count = count + value">` и виджет определения области: {localFn:'&myAttr'}, то изолирование свойства localFn будет указывать на обертку функции для `Count = Count + value expression`. Часто это желательно, чтобы передать данные из изолированной области через выражение и в родительскую область, что можно сделать через карту имен локальной переменной и значения в выражение wrapper fn. Например, если выражение `increment(amount)`, то можно указать значение `amount` путем вызова `localFn` как `localFn({amount: 22})`.

  * `controller` - функция-конструктор контроллера. Экземпляр контроллера создается перед стадией компоновки, и становится доступен другим директивам, если они запросят его по имени (см. запрос атрибута). Это позволяет директивам общаться друг с другом и дополнять поведение друг друга. Контроллер внедряется со следующими локалями:

    * `$scope` - текущая область видимости, связанная с элементом
    * `$element` - текущий элемент
    * `$attrs` - текущие атрибуты объекта в элементе
    * `$transclude` - включающая функция линковки, предварительно связанная с правильной областью включения: `function(cloneLinkingFn)`.

  * `require` - запрос другого контроллера передается в функцию линковки текущей директивы. 
    Принимает имя директивы контроллера для передачи. Если такой контроллер не будет найден, произойдет ошибка. 
    Имя может иметь префикс:

    * `?` - не возвращать ошибку. Актуально при запросе дополнительных зависимостей.
    * `^` - искать контроллер так же в родительских элементах.


  * `restrict` - cтрока вида `EACM` (Element, Attribute, Class, Comment), задающая стиль определения директивы. Если опущена, директивы допускается только в атрибутах.

    * `E` - имя элемента:: `<my-directive></my-directive>`
    * `A` - атрибут: `<div my-directive="exp"></div>`
    * `C` - класс: `<div class="my-directive: exp;"></div>`
    * `M` - комментарий: `<!-- directive: my-directive exp -->`

  * `template` - заменяет текущий элемент с содержимым HTML. Процесс замены заменяет все атрибуты/классы старого элемента на новые. См. раздел {@link guide/directive#Components Создание компонентов} в секции ниже для получения дополнительной информации.

    Можно использовать определение `template` как строку, представляющую шаблон или функцию, которая принимает два аргумента `tElement` и `tAttrs` (описано ниже в API функции `compile`) и возвращается строку, представляющую шаблон.

  * `templateUrl` - то же `template`, но загружаемый с указанного URL. Поскольку загрузка шаблона является асинхронной компиляция/линковка приостанавливается пока шаблон не будет загружен.

    Можно использовать определение `templateUrl` как строку, представляющую шаблон или функцию, которая принимает два аргумента `tElement` и `tAttrs` (описано ниже в API функции `compile`) и возвращается строку, представляющую URL.

  * `replace` - если установлено true, то шаблон заменит текущий элемент, а не добавится внутрь.

  * `transclude` - компиляция содержимого элемента и делание его доступным для директивы. Обычно используется с {@link api/ng.directive:ngTransclude
    ngTransclude}. Преимуществом является то, что включение связующей функции получает включение функции, предварительно связанной с правильной областью видимости. В стандартной установке виджет создает изолированную область видимости, но не включает потомков и родственников изолированной области видимости. Это дает возможность виджету, иметь приватное состояние и включение будет привязано к родительской (предварительно изолированной) области видимости.

    * `true` - включение содержимого директивы.
    * `'element'` - включение всего элемента, включая любые определения директив с более низким приоритетом.


  * `compile`: функция компиляции, описанная в следующем разделе.

  * `link`: Это функция линковки, описанная в следующем разделе. Это свойство используется только тогда, когда свойство `compile` не определено.

## Функция компиляции

<pre>
  function compile(tElement, tAttrs, transclude) { ... }
</pre>

Функция компиляции работает с функцией преобразования шаблонов DOM. Так как большинство директив не преобразуют шаблон, она не используется часто. Примеры, которые требуют функции компиляции являются директивами, которые преобразуют шаблон DOM, такие как {@link api/ng.directive:ngRepeat ngRepeat} или загружать содержимое асинхронно, таких как {@link api/ng.directive:ngView ngView}. Функция компиляции принимает следующие аргументы.

  * `tElement` - элемент шаблона — элемент, в котором была объявлена директива​​. Можно с уверенностью преобразовать в шаблон только элемент и дочерние элементы.

  * `tAttrs` - шаблон атрибутов — унифицированный список атрибутов, объявленных в этом элементе, распределяется между всеми директивами функций компиляции. См. {@link guide/directive#Attributes Атрибуты}.

  * `transclude` - включающая функция линковки: `function(scope, cloneLinkingFn)`.

Примечание: созданные экземпляры шаблона и связей не могут быть такими же объектами, если шаблон был клонирован. По этой причине не безопасно делать в функции компиляции что-нибудь кроме DOM преобразования, которое применяется ко всем клонам DOM. В частности, регистрация наблюдателей за DOM должна производится в связующей функции, а не в функции компиляции.

Функция компиляции может возвращать как функцию, так и объект.

* возврат функции равносилен регистрации связывающей функции при помощи свойства `link` объекта config когда функция компиляции пустая.

* возврат объекта с функцией(ями) зарегистрированными через `pre` и `post` позволяет контролировать, когда в процессе линковки должна быть вызвана функция линковки. Подробнее про функции предварительной и завершающей линковки ниже.


## Функция линковки

<pre>
  function link(scope, iElement, iAttrs, controller) { ... }
</pre>

Функция связывания отвечает за регистрацию слушателей DOM так же, как и за обновление DOM. Она вызывается после того, как шаблон был клонирован. Это то место, где должна располагаться большая часть логики директив.

  * `scope` - {@link api/ng.$rootScope.Scope область видимости} — область, используемая директивой для регистрации {@link api/ng.$rootScope.Scope#$watch наблюдателей}.

  * `iElement` - экземпляр элемента — элемент, на котором определена директива. Безопасно манипулировать дочерними элементами только в функции postLink, так как потомки уже были связаны между собой.

  * `iAttrs` - атрибуты экземпляра - Нормализованный список атрибутов данного элемента, доступный для всех функций связывания директив. См. {@link
    guide/directive#Attributes Атрибуты}.

  * `controller` - экземпляр контроллера - Экземпляр контроллера в случае, если хотя бы одна директива элемента определяет контроллер. Контроллер доступен для всех директив, что позволяет использовать его в качестве канала связи между ними.



### Функция предварительной линковки (Pre-linking)

Вызывается до того, как дочерний элемент будет связан. Не безопасна для выполнения изменений DOM модели, так как функция связывания компилятора не сможет найти правильные элементы для связывания.

### Функция завершающей линковки (Post-linking)

Вызывается после того, как дочерний элемент был связан. В функции пост связывания можно безопасно производить изменения DOM модели.

<a name="Attributes"></a>
## Атрибуты

Объект {@link api/ng.$compile.directive.Attributes Attributes} - переданный в качестве параметра в функции link() или compile() - предоставляет доступ к:

  * *нормализованным названиям атрибутов*: Так как директивы, например, 'ngBind' могут быть представлены в разных видах, например, 'ng:bind', или 'x-ng-bind', объект атрибутов предоставляет нормализованный доступ к атрибутам.

  * *директиве внутренней коммуникации*: Все директивы, предоставляющие доступ к таким же атрибутам экземпляров объектов, которые позволяют использовать атрибуты директивы объекта как связь между директивами.

  * *поддержке интерполяции*: интерполяция атрибутов заданная атрибуту объекта позволит другим директивам читать интерполированное значение.

  * *наблюдению за интерполированными атрибутами*: Используйте `$observe` чтобы наблюдать изменения значений атрибутов, которые содержат интерполяции (напр. `src="{{bar}}"`). Это не только очень эффективно, но также единственный способ легко получить фактическое значение, поскольку во время стадии компоновки интерполяция еще не оценена и поэтому на то время значение становится `undefined`.

<pre>
function linkingFn(scope, elm, attrs, ctrl) {
  // получение значения атрибута
  console.log(attrs.ngModel);

  // изменение атрибута
  attrs.$set('ngModel', 'new value');

  // наблюдение за изменениями для обновления значения атрибута
  attrs.$observe('ngModel', function(value) {
    console.log('ngModel has changed value to ' + value);
  });
}
</pre>


# Понимание включения и областей

Часто хочется, чтобы компоненты можно было использовать повторно. Ниже представлен псевдо код, который показывает, как может работать упрощенный компонент диалога.

<pre>
  <div>
    <button ng-click="show=true">show</button>
    <dialog title="Hello {{username}}."
            visible="show"
            on-cancel="show = false"
            on-ok="show = false; doSomething()">
       Body goes here: {{username}} is {{title}}.
    </dialog>
  </div>
</pre>

Клик по кнопке "show" откроет диалог. Этот диалог имеет заголовок, к которому привязан `username`, а также он будет содержать тело, которое мы хотим вставить в диалог.

Вот пример того, как может выглядеть определение шаблона для виджета `dialog`.

<pre>
  <div ng-show="visible">
    <h3>{{title}}</h3>
    <div class="body" ng-transclude></div>
    <div class="footer">
      <button ng-click="onOk()">Save changes</button>
      <button ng-click="onCancel()">Close</button>
    </div>
  </div>
</pre>

Это не отобразится должным образом, пока мы не воспользуемся магией области видимости.

Первый вопрос, на который мы должны ответить: как определить название `title` шаблона диалогового окна, но конкретное место хотелось бы связать с именем пользователя `username`. Кроме того, нужно задать кнопкам функции `onOk` и `onCancel`, которые будут присутствовать в области видимости. Это ограничивает полезность виджета. Для решения вопроса с отображением мы используем `locals` для создания локальных переменных, которые шаблон ожидает следующим образом:

<pre>
  scope: {
    title: '@',             // заголовок использует связывание данных в родительской области
    onOk: '&',              // создаем представителя функции onOk
    onCancel: '&',          // создаем представителя функции onCancel
    visible: '='            // установка видимости для начала связывания данных
  }
</pre>

Создание локальных свойств в области виджета порождает две проблемы:

  1. изоляция -  если пользователь забудет задать название `title` атрибута диалогового виджета, то диалоговый шаблон будет связан с родительской областью видимости. Это непредсказуемо и нежелательно.

  2. включение - включенный DOM может увидеть локальный виджет, который, может перезаписать свойства, нужные для включения связывания данных. В нашем примере заголовок `title` виджета переопределяет заголовок `title` включения.


Для решения проблемы нехватки изоляции, директивы определяют новую изолированную область. Эта область не наследуется от дочерней области, и потому мы можем не волноваться о том, что случайно затрется какое-либо свойство.

Однако изолированная область видимости создает новую проблему: если включенный DOM является дочерним виджетом изолированной области видимости, то он не может быть связан ни с чем. По этой причине включенная область видимости является потомком оригинальной области видимости, перед виджетом,созданным в изолированной области видимости для его локальных переменных. Это делает включение и виджет изолированной областипотомками одного уровня.

Это может показаться неожиданно сложным, но так пользователя и разработчика виджетов ожидает меньше всего неожиданностей.

Таким образом, окончательное определение директивы выглядит примерно так:

<pre>
transclude: true,
scope: {
    title: '@',             // заголовок использует связывание данных в родительской области
    onOk: '&',              // создаем представителя функции onOk
    onCancel: '&',          // создаем представителя функции onCancel
    visible: '='            // установка видимости для начала связывания данных
},
restrict: 'E',
replace: true
</pre>

<a name="Components"></a>
# Создание компонентов

Часто желательно, заменить одну директиву с более сложной структурой DOM. Это позволяет сократить объем директив и сделать их пригодными для повторно используемых компонентов, из которых может быть построено приложение.

Ниже представлен пример создания виджета, который можно использовать повторно.

<doc:example module="zippyModule">
  <doc:source>
   <script>
     function Ctrl3($scope) {
       $scope.title = 'Lorem Ipsum';
       $scope.text = 'Neque porro quisquam est qui dolorem ipsum quia dolor...';
     }

     angular.module('zippyModule', [])
       .directive('zippy', function(){
         return {
           restrict: 'C',
           // Этот HTML заменит директиву zippy.
           replace: true,
           transclude: true,
           scope: { title:'@zippyTitle' },
           template: '<div>' +
                       '<div class="title">{{title}}</div>' +
                       '<div class="body" ng-transclude></div>' +
                     '</div>',
           // Связующая функция добавит поведение к шаблону
           link: function(scope, element, attrs) {
                 // Элемент заголовка
             var title = angular.element(element.children()[0]),
                 // Состояние Opened / closed
                 opened = true;

             // Клик по заголовку должен открыть/закрыть zippy
             title.bind('click', toggle);

             // Переключение состояния closed/opened
             function toggle() {
               opened = !opened;
               element.removeClass(opened ? 'closed' : 'opened');
               element.addClass(opened ? 'opened' : 'closed');
             }

             // инициализация zippy
             toggle();
           }
         }
       });
   </script>
   <style>
     .zippy {
       border: 1px solid black;
       display: inline-block;
       width: 250px;
     }
     .zippy.opened > .title:before { content: '▼ '; }
     .zippy.opened > .body { display: block; }
     .zippy.closed > .title:before { content: '► '; }
     .zippy.closed > .body { display: none; }
     .zippy > .title {
       background-color: black;
       color: white;
       padding: .1em .3em;
       cursor: pointer;
     }
     .zippy > .body {
       padding: .1em .3em;
     }
   </style>
   <div ng-controller="Ctrl3">
     Title: <input ng-model="title"> <br>
     Text: <textarea ng-model="text"></textarea>
     <hr>
     <div class="zippy" zippy-title="Details: {{title}}...">{{text}}</div>
   </div>
  </doc:source>
  <doc:scenario>
    it('should bind and open / close', function() {
      input('title').enter('TITLE');
      input('text').enter('TEXT');
      expect(element('.title').text()).toEqual('Details: TITLE...');
      expect(binding('text')).toEqual('TEXT');

      expect(element('.zippy').prop('className')).toMatch(/closed/);
      element('.zippy > .title').click();
      expect(element('.zippy').prop('className')).toMatch(/opened/);
    });
  </doc:scenario>
</doc:example>
