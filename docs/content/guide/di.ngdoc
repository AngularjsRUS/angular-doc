@ngdoc overview
@name Developer Guide: Внедрение зависимости
@description

# Внедрение зависимости (Dependency Injection)

Внедрение зависимостей (DI) - это шаблон проектирования программного обеспечения, связанный с захватом кодом его зависимостей.

Для детального ознакомления с DI, посмотрите статью {@link http://ru.wikipedia.org/wiki/%C2%ED%E5%E4%F0%E5%ED%E8%E5_%E7%E0%E2%E8%F1%E8%EC%EE%F1%F2%E8 Внедрение зависимостей} в Википедии, {@link http://martinfowler.com/articles/injection.html Inversion of Control} Мартина Фаулера (Martin Fowler), или почитайте про DI в вашей любимой книге про шаблоны проектирования ПО.

## DI в двух словах

Существует всего 3 способа, как объект или функция может захватить зависимости:

  1. Зависимость может быть создана посредством обычного вызова оператора `new`.

  2. Зависимость может быть найдена при помощи ссылки на глобальную переменную.

  3. Зависимость может быть передана туда, где она необходима.


Первые два способа создания или поиска зависимостей не оптимальны, потому что они четко задают зависимость, 
усложняя (или делая невозможным) изменение зависимости. Это особенно проблематично при тестировании, где всегда 
желательно включать имитаторы зависимостей для изоляции тестов.

Третий способ наиболее пригоден, так как он снимает с компонента ответственность за поиск зависимости. Она 
просто передается компоненту.

<pre>
  function SomeClass(greeter) {
    this.greeter = greeter
  }
  
  SomeClass.prototype.doSomething = function(name) {
    this.greeter.greet(name);
  }
</pre>

В примере выше класс `SomeClass` не заботится о том, где расположена зависимость `greeter`, он просто получает 
`greeter` во время выполнения.

Это приятно, но ответственность за захват зависимости перекладывается на код, отвечающий за создание `SomeClass`.

Для управления ответственностью за создание зависимостей в каждом Angular-приложении есть 
{@link api/angular.injector инжектор}. Инжектор - это локатор служб отвечающий за создание и поиск зависимостей.


Вот пример использования инжектора.
<pre>
  // Обеспечение обвязки информации в модуле
  angular.module('myModule', []).
  
    // Обучение инжектора построению 'greeter'а
    // Заметьте, что greeter сам по себе зависит от '$window'
    factory('greeter', function($window) {
      // Это фабричная функция, которая отвечает за
      // создание 'greet' службы.
      return {
        greet: function(text) {
          $window.alert(text);
        }
      };
    });

  // Создание нового инжектора из модуля
  // (Это обычно производится автоматически загрузчиком Angular)
  var injector = angular.injector(['myModule', 'ng']);
  
  // Запрашивает какую-либо зависимость у инжектора
  var greeter = injector.get('greeter');
</pre>

Запрос зависимостей решает проблему четкого прописывания их в коде, но так же это означает, что инжектор 
должен быть доступен в любом месте приложения, что противоречит 
{@link http://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%94%D0%B5%D0%BC%D0%B5%D1%82%D1%80%D1%8B 
Закону Деметры}. Для того, чтобы это исправить, мы передаем ответственность за поиск зависимостей инжектору 
описывая их следующим образом:

<pre>
  <!-- Возьмем этот HTML -->
  <div ng-controller="MyController">
    <button ng-click="sayHello()">Hello</button>
  </div>
</pre>  
<pre>
  // Добавляем определение этого контролера
  function MyController($scope, greeter) {
    $scope.sayHello = function() {
      greeter.greet('Hello World');
    };
  }
  
  // Директива 'ng-controller' делает это за кулисами
  injector.instantiate(MyController);
</pre>

Заметьте, что, так как `ng-controller` создает экземпляр класса, то он может удовлетворить и все зависимости 
`MyController`, который при этом даже не догадывается про инжектор. Это лучшее решение. Код приложения просто 
запрашивает необходимые зависимости, не используя инжектор. Такая структура не противоречит Закону Деметры.

# Аннотация зависимости

Как инжектор узнает, какой сервис должен быть внедрен?

Разработчик приложения должен предоставить пояснение, что инжектор используется для разрешения зависимостей. 
Через Angular некоторые функции API вызываются с помощью инжектора, в соответствии с документацией API. 
Инжектор должен знать, какие сервисы внедряются в функцию. Ниже приведены три эквивалентных способа разметки 
кода с информацией о именах сервисов. Они могут использоваться как взаимозаменяемые, если вы считаете это нужным, 
и быть эквивалентными.

# Выводы о зависимостях

Самый простой способ захватить зависимости - это использовать названия зависимостей в качестве названий параметров 
метода.

<pre>
  function MyController($scope, greeter) {
    ...
  }
</pre>

Получив метод инжектор может узнать, какие зависимости нужно внедрить, исследуя объявление метода и выделяя названия 
параметров. В коде выше `$scope` и `greeter` являются сервисами, которые нужно внедрить в метод.

Не смотря на простоту, этот способ не будет работать при использовании JavaScript минимизаторов/обфускаторов, так 
как они изменяют названия параметров метода. Таким образом, этот способ описания может быть полезен только для 
{@link http://www.pretotyping.org/ прототипирования} и демо приложений.

# аннотация `$inject`

Для того, чтобы разрешить минимизаторам изменять названия параметров и при этом внедрять правильные сервисы, метод 
должен быть описан со свойством `$inject`. Свойство `$inject` - это массив названий внедряемых сервисов.

<pre>
  var MyController = function(renamed$scope, renamedGreeter) {
    ...
  }
  MyController.$inject = ['$scope', 'greeter'];
</pre>

Необходимо позаботиться о том, что `$inject` аннотация синхронизировалась только с фактическими аргументами в 
объявлении функции.

Этот метод аннотации полезен для деклараций контроллера, поскольку он назначает аннотационную информацию с функцией.

# Встроенная аннотация

Иногда использование `$inject` аннотации стиля не удобно, например, когда аннотируются директивы.

Например:
<pre>
  someModule.factory('greeter', function($window) {
    ...;
  });
</pre>

Результаты в разрастание кода в связи с необходимостью временной переменной:
<pre>
  var greeterFactory = function(renamed$window) {
    ...;
  };
  
  greeterFactory.$inject = ['$window'];
  
  someModule.factory('greeter', greeterFactory);
</pre>

По этой причине третий стиль аннотация точно такой же.
<pre>
  someModule.factory('greeter', ['$window', function(renamed$window) {
    ...;
  }]);
</pre>

Имейте в виду, что все стили аннотации эквивалентны и могут быть использованы в любом месте Angular, 
где поддерживаются инъекции.

# Как использовать внедрение зависимости?

Внедрение зависимости встречается в Angular повсеместно, но чаще используется в контроллерах и фабричных методах.

## Внедрение зависимости в контроллерах

Контроллеры имеют классы, которые отвечают за поведение приложения. Рекомендуем объявлять контроллеры так:

<pre>
  var MyController = function($scope, dep1, dep2) {
    ...
    $scope.aMethod = function() {
      ...
    }
  }
  MyController.$inject = ['$scope', 'dep1', 'dep2'];
</pre>


## Фабричные методы

Фабричные методы отвечают за создание большинства объектов в Angular. Например, директив, сервисов и фильтров. 
Рекомендуем регистрировать фабричные методы в модуле так:

<pre>
  angular.module('myModule', []).
    config(['depProvider', function(depProvider){
      ...
    }]).
    factory('serviceId', ['depService', function(depService) {
      ...
    }]).
    directive('directiveName', ['depService', function(depService) {
      ...
    }]).
    filter('filterName', ['depService', function(depService) {
      ...
    }]).
    run(['depService', function(depService) {
      ...
    }]);
</pre>
