@ngdoc overview
@name Обзор концепции
@description

# Обзор

Этот документ дает представление об основных компонентах Angular и о том, как они работают вместе.
Вот они:

  * {@link concepts#startup быстрый старт (startup)} - программа Hello world
  * {@link concepts#runtime среда исполнения (runtime)} - обзор среды исполнения Angular
  * {@link concepts#scope область видимости (scope)} - связующее звено между представлением и контроллером
  * {@link concepts#controller контроллер (controller)} - поведение програмы
  * {@link concepts#model модель (model)} - данные програмы
  * {@link concepts#view вид или представление (view)} - то что выидит пользователь
  * {@link concepts#directives директивы (directives)} - расширение HTML-синтаксиса
  * {@link concepts#filters фильтры (filters)} - форматируют данные в соответствии с пользовательской локалью
  * {@link concepts#injector ижектор (injector)} - собирает приложение
  * {@link concepts#module модуль (module)} - настраивает инжектор
  * {@link concepts#angular_namespace `$`} - пространство имен Angular

<a name="startup"></a>
# Быстрый старт

Для начала, сдвинемся с мертвой точки (см. схему и пример ниже):

<img class="pull-right" style="padding-left: 3em;" src="img/guide/concepts-startup.png">

  1. Браузер загружает HTML-документ и строит DOM.
  2. Браузер загружает скрипт angular.js
  3. Angular ожидает события `DOMContentLoaded`
  4. Angular ищет {@link api/ng.directive:ngApp ng-app} {@link guide/directive директиву}, которая определяет область действия фреймворка
  5. {@link guide/module Модуль}, указанный в директиве {@link api/ng.directive:ngApp ng-app} (если таковой имеется), используется для конфигурации {@link api/AUTO.$injector $injector}
  6. {@link api/AUTO.$injector $injector} используется для создания сервиса {@link
     api/ng.$compile $compile}, а за одно и {@link
     api/ng.$rootScope $rootScope}
  7. Сервис {@link api/ng.$compile $compile} используется для компиляции DOM и связки его с {@link api/ng.$rootScope $rootScope}
  8. {@link guide/directive Директива} {@link api/ng.directive:ngInit ng-init}  присваивает значение `World` свойству `name` в области видимости {@link guide/scope (scope)}
  9. `{{name}}` {@link api/ng.$interpolate преобразует} выражение в `Hello World!`

<div class="clear">
</div>
<example>
  <file name="index.html">
    <p ng-init=" name='World' ">Hello {{name}}!</p>
  </file>
</example>


<a name="runtime"></a>
# Среда исполнения

<img class="pull-right" style="padding-left: 3em; padding-bottom: 1em;" src="img/guide/concepts-runtime.png">

Диаграмма и пример ниже демонстрируют как Angular взаимодействует с событийным циклом браузера.

  1. Событийный цикл браузера ждёт событие. Событие это действие пользователя, событие таймера или
     событие от сети (ответ от сервера).
  2. Выполняется колбэк в контексте JavaScript. Он может модифицировать DOM.
  3. Как только колбэк закончил выполнение, браузер покидает контекст JavaScript и перерисовывает
     представление основываясь на изменениях DOM.

Angular меняет нормальный поток событий в JavaScript, представляя свой собственный цикл обработки
событий. Это разбивает JavaScript на два контекста выполнения: классический и Angular. Только те
операции, которые принадлежат контексту выполнения Angular, получат пользу от связывания данных,
обработки исключений, привязки к свойствам и т.д. в Angular. Также вы можете использовать $apply(),
чтобы войти в контекст выполнения Angular из JavaScript. Имейте ввиду, что в большинстве мест
(контроллеры, сервисы) $apply уже был вызван за вас директивой, которая обрабатывает событие.
Явный вызов $apply нужен только в тех случаях, когда реализуется пользовательское событие, или
при работе с колбэками сторонних библиотек.

  1. Входим в контекст выполнения Angular с помощью вызова {@link guide/scope scope}`. `{@link
     api/ng.$rootScope.Scope#$apply $apply}`(stimulusFn)`. Где `stimulusFn` действие, которое
     вы хотите выполнить в контексте выполнения Angular.
  2. Angular выполняет функцию `stimulusFn()`, которая обычно меняет состояние приложения.
  3. Angular входит в {@link api/ng.$rootScope.Scope#$digest $digest} цикл. Цикл состоит
     из двух меньших циклов, которые обрабатывают очередь {@link
     api/ng.$rootScope.Scope#$evalAsync $evalAsync} и список {@link
     api/ng.$rootScope.Scope#$watch $watch}. Цикл {@link api/ng.$rootScope.Scope#$digest
     $digest} продолжает итерирование до тех пор пока модель не стабилизируется,
     что означает, что очередь {@link api/ng.$rootScope.Scope#$evalAsync $evalAsync}
     пуста и в списке {@link api/ng.$rootScope.Scope#$watch $watch} не осталось
     никаких изменений.
  4. Очередь {@link api/ng.$rootScope.Scope#$evalAsync $evalAsync} используется для того, чтобы
     запланировать работу, которая должна выполниться вне текущего стекового фрейма, но перед
     тем, как браузер отрисует представление. Это обычно делается с помощью `setTimeout(0)`, но
     подход с `setTimeout(0)` медленный и может вызвать мерцание на странице, так как браузер
     отрисовывает представление после каждого события.
  5. Список {@link api/ng.$rootScope.Scope#$watch $watch} - это набор выражений, которые
     могли измениться с прошлой итерации. Если обнаружено изменение, вызывается
     функция `$watch`, которая, как правило, обновляет значение в DOM.
  6. После того, как цикл {@link api/ng.$rootScope.Scope#$digest $digest} заканчивает,
     выполнение выходит из Angular и JavaScript контекстов. За этим следует отрисовка
     браузером DOM, чтобы отобразить изменения.

Вот каким образом в примере `Hello world` достигнут эффект связывания данных, когда пользователь
вводит текст в текстовое поле.

  1. Во время фазы компиляции:
     1. {@link api/ng.directive:ngModel ng-model} и {@link
        api/ng.directive:input input} {@link guide/directive
        directive} устанавливают `keydown` слушателя
        на поле `<input>`.
     2. Вставка {@link api/ng.$interpolate &#123;&#123;name&#125;&#125; }
        настраивает {@link api/ng.$rootScope.Scope#$watch $watch}, чтобы
        получать уведомления при изменении `name`.
  2. Во время фазы выполнения:
     1. Нажатие клавиши '`X`' заставляет браузер послать событие `keydown`
        на текстовом поле.
     2. Директива {@link api/ng.directive:input input} захватывает
        изменение значения на текстовом поле и вызывает {@link
        api/ng.$rootScope.Scope#$apply $apply}`("name = 'X';")` для
        обновления модели внутри контекста выполнения Angular.
     3. Angular применяет `name = 'X';` к моделе.
     4. Начинается цикл {@link api/ng.$rootScope.Scope#$digest $digest}.
     5. Список {@link api/ng.$rootScope.Scope#$watch $watch} замечает изменение
        свойства `name` и уведомляет вставку {@link api/ng.$interpolate
        &#123;&#123;name&#125;&#125; }, что в итоге обновляет DOM.
     6. Angular выходит из контекста выполнения, что приводит к выходу из
        события `keydown` и вместе с этим из контекста выполнения JavaScript.
     7. Браузер перерисовывает представление с обновлённым текстом.

<div class="clear">
</div>
<example>
  <file name="index.html">
    <input ng-model="name">
    <p>Hello {{name}}!</p>
  </file>
</example>

<a name="scope"></a>
#Scope

The {@link guide/scope scope} is responsible for detecting changes to the model section and
provides the execution context for expressions. The scopes are nested in a hierarchical structure
which closely follow the DOM structure. (See individual directive documentation to see which
directives cause a creation of new scopes.)

The following example demonstrates how the `name` {@link guide/expression expression} will evaluate
into a different value depending on which scope it is evaluated in. The example is followed by
a diagram depicting the scope boundaries.

<div class="clear">
</div>
<div class="show-scope">
<example>
  <file name="index.html">
    <div ng-controller="GreetCtrl">
      Hello {{name}}!
    </div>
    <div ng-controller="ListCtrl">
      <ol>
        <li ng-repeat="name in names">{{name}}</li>
      </ol>
    </div>
  </file>
  <file name="script.js">
    function GreetCtrl($scope) {
      $scope.name = 'World';
    }

    function ListCtrl($scope) {
      $scope.names = ['Igor', 'Misko', 'Vojta'];
    }
  </file>
  <file name="style.css">
    .show-scope .doc-example-live.ng-scope,
    .show-scope .doc-example-live .ng-scope  {
      border: 1px solid red;
      margin: 3px;
    }
  </file>
</example>
</div>

<img class="center" src="img/guide/concepts-scope.png">


<a name="controller"></a>
# Controller

<img class="pull-right" style="padding-left: 3em; padding-bottom: 1em;" src="img/guide/concepts-controller.png">

A controller is the code behind the view. Its job is to construct the model and publish it to the
view along with callback methods. The view is a projection of the scope onto the template (the
HTML). The scope is the glue which marshals the model to the view and forwards the events to the
controller.

The separation of the controller and the view is important because:

  * The controller is written in JavaScript. JavaScript is imperative. Imperative is a good fit
    for specifying application behavior. The controller should not contain any rendering
    information (DOM references or HTML fragments).
  * The view template is written in HTML. HTML is declarative. Declarative is a good fit for
    specifying UI. The View should not contain any behavior.
  * Since the controller is unaware of the view, there could be many views for the same
    controller. This is important for re-skinning, device specific views (i.e. mobile vs desktop),
    and testability.

<div class="clear">
</div>
<example>
  <file name="index.html">
    <div ng-controller="MyCtrl">
      Hello {{name}}!
      <button ng-click="action()">
        OK
      </button>
    </div>
  </file>
  <file name="script.js">
    function MyCtrl($scope) {
      $scope.action = function() {
        $scope.name = 'OK';
      }

      $scope.name = 'World';
    }
  </file>
</example>


<a name="model"></a>
# Model

<img class="pull-right" style="padding-left: 3em; padding-bottom: 1em;" src="img/guide/concepts-model.png">

The model is the data which is merged with the template to produce the view. To be able to
render the model into the view, the model has to be able to be referenced from the scope. Unlike many
other frameworks Angular makes no restrictions or requirements on the model. There are no classes
to inherit from or special accessor methods for accessing or changing the model. The model can be
primitive, object hash, or a full object Type. In short the model is a plain JavaScript object.


<div class="clear">
</div>


<a name="view"></a>
# View

<img class="pull-right" style="padding-left: 3em; padding-bottom: 1em;" src="img/guide/concepts-view.png">

The view is what the user sees. The view begins its life as a template, is merged with the
model and finally rendered into the browser DOM. Angular takes a very different approach to
rendering the view compared to most other templating systems.

  * **Others** - Most templating systems begin as an HTML string with special templating markup.
    Often the template markup breaks the HTML syntax which means that the template can not be
    edited by an HTML editor. The template string is then parsed by the template engine, and
    merged with the data. The result of the merge is an HTML string. The HTML string is then
    written to the browser using the `.innerHTML`, which causes the browser to render the HTML.
    When the model changes the whole process needs to be repeated. The granularity of the template
    is the granularity of the DOM updates. The key here is that the templating system manipulates
    strings.
  * **Angular** - Angular is different, since its templating system works on DOM objects not on
    strings. The template is still written in an HTML string, but it is HTML (not HTML with
    template sprinkled in.) The browser parses the HTML into the DOM, and the DOM becomes the input to
    the template engine known as the {@link api/ng.$compile compiler}. The compiler
    looks for {@link guide/directive directives} which in turn set up {@link
    api/ng.$rootScope.Scope#$watch watches} on the model. The result is a
    continuously updating view which does not need template model re-merging. Your model becomes
    the single source-of-truth for your view.

<div class="clear">
</div>

<example>
  <file name="index.html">
    <div ng-init="list = ['Chrome', 'Safari', 'Firefox', 'IE'] ">
      <input ng-model="list" ng-list> <br>
      <input ng-model="list" ng-list> <br>
      <pre>list={{list}}</pre> <br>
      <ol>
        <li ng-repeat="item in list">
          {{item}}
        </li>
      </ol>
    </div>
  </file>
</example>


<a name="directives"></a>
# Directives

A directive is a behavior or DOM transformation which is triggered by the presence of a custom attribute,
element name, or a class name. A directive allows you to extend the HTML vocabulary in a
declarative fashion. Following is an example which enables data-binding for the `contenteditable`
in HTML.

<example module="directive">
  <file name="script.js">
    angular.module('directive', []).directive('contenteditable', function() {
      return {
        require: 'ngModel',
        link: function(scope, elm, attrs, ctrl) {
          // view -> model
          elm.bind('blur', function() {
            scope.$apply(function() {
              ctrl.$setViewValue(elm.html());
            });
          });

          // model -> view
          ctrl.$render = function(value) {
            elm.html(value);
          };

          // load init value from DOM
          ctrl.$setViewValue(elm.html());
        }
      };
    });
  </file>
  <file name="index.html">
    <div contentEditable="true" ng-model="content">Edit Me</div>
    <pre>model = {{content}}</pre>
  </file>
  <file name="style.css">
    div[contentEditable] {
      cursor: pointer;
      background-color: #D0D0D0;
      margin-bottom: 1em;
      padding: 1em;
    }
  </file>
</example>

<a name="filters"></a>
# Filters

{@link api/ng.$filter Filters} perform data transformation. Typically
they are used in conjunction with the locale to format the data in locale specific output.
They follow the spirit of UNIX filters and use similar syntax `|` (pipe).

<example>
  <file name="index.html">
    <div ng-init="list = ['Chrome', 'Safari', 'Firefox', 'IE'] ">
      Number formatting: {{ 1234567890 | number }} <br>
      array filtering <input ng-model="predicate">
      {{ list | filter:predicate | json }}
    </div>
  </file>
</example>


<a name="module"></a>
<a name="injector"></a>
# Modules and the Injector

<img class="pull-right" style="padding-left: 3em; padding-bottom: 1em;" src="img/guide/concepts-module-injector.png">

The {@link api/AUTO.$injector injector} is a service locator. There is a single
{@link api/AUTO.$injector injector} per Angular {@link
api/ng.directive:ngApp application}. The {@link
api/AUTO.$injector injector} provides a way to look up an object instance by its
name. The injector keeps an internal cache of all objects so that repeated calls to get the same
object name result in the same instance. If the object does not exist, then the {@link
api/AUTO.$injector injector} asks the instance factory to create a new instance.

A {@link api/angular.Module module} is a way to configure the injector's instance factory, known
as a {@link api/AUTO.$provide provider}.

<div class='clear'></div>
<pre>
  // Create a module
  var myModule = angular.module('myModule', [])

  // Configure the injector
  myModule.factory('serviceA', function() {
    return {
      // instead of {}, put your object creation here
    };
  });

  // create an injector and configure it from 'myModule'
  var $injector = angular.injector(['myModule']);

  // retrieve an object from the injector by name
  var serviceA = $injector.get('serviceA');

  // always true because of instance cache
  $injector.get('serviceA') === $injector.get('serviceA');
</pre>


But the real magic of the {@link api/AUTO.$injector injector} is that it can be
used to {@link api/AUTO.$injector#invoke call} methods and {@link
api/AUTO.$injector#instantiate instantiate} types. This subtle feature is what
allows the methods and types to ask for their dependencies instead of having to look for them.

<pre>
  // You write functions such as this one.
  function doSomething(serviceA, serviceB) {
    // do something here.
  }

  // Angular provides the injector for your application
  var $injector = ...;

  ///////////////////////////////////////////////
  // the old-school way of getting dependencies.
  var serviceA = $injector.get('serviceA');
  var serviceB = $injector.get('serviceB');

  // now call the function
  doSomething(serviceA, serviceB);

  ///////////////////////////////////////////////
  // the cool way of getting dependencies.
  // the $injector will supply the arguments to the function automatically
  $injector.invoke(doSomething); // This is how the framework calls your functions
</pre>

Notice that the only thing you needed to write was the function, and list the dependencies in the
function arguments. When angular calls the function, it will use the {@link
api/AUTO.$injector#invoke call} which will automatically fill the function
arguments.

Examine the `ClockCtrl` below, and notice how it lists the dependencies in the constructor. When the
{@link api/ng.directive:ngController ng-controller} instantiates
the controller it automatically provides the dependencies. There is no need to create
dependencies, look for dependencies, or even get a reference to the injector.

<example module="timeExampleModule">
  <file name="index.html">
    <div ng-controller="ClockCtrl">
      Current time is: {{ time.now }}
    </div>
  </file>
  <file name="script.js">
    angular.module('timeExampleModule', []).
      // Declare new object called time,
      // which will be available for injection
      factory('time', function($timeout) {
        var time = {};

        (function tick() {
          time.now = new Date().toString();
          $timeout(tick, 1000);
        })();
        return time;
      });

    // Notice that you can simply ask for time
    // and it will be provided. No need to look for it.
    function ClockCtrl($scope, time) {
      $scope.time = time;
    }
  </file>
</example>


<a name="angular_namespace"></a>
# Angular Namespace

To prevent accidental name collision, Angular prefixes names of objects which could potentially
collide with `$`. Please do not use the `$` prefix in your code as it may accidentally collide
with Angular code.
