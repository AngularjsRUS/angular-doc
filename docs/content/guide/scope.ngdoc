@ngdoc overview
@name Developer Guide: Области видимости
@description

# Что такое области видимости (scopes)?

{@link api/ng.$rootScope.Scope Область видимости} является объектом, относящимся к модели приложения. 
Это контекст выполнения {@link expression выражений}. Области расположены в иерархической структуре, 
имитирующей DOM-структуру приложения. Они могут отслеживать изменения выражений и распространять события.

## Характеристики областей

  - Области предоставляют API ({@link api/ng.$rootScope.Scope#$watch $watch}) для наблюдения за изменениями модели.

  - Области предоставляют API ({@link api/ng.$rootScope.Scope#$apply $apply}) для распространения любых изменений модели через систему внутри «сферы Angular» (контроллеры, сервисы, обработчики событий)

  - Области могут быть вложенными, чтобы изолировать компоненты приложений, обеспечивая при этом доступ к общим свойствам модели. Область (прототипически) наследует свойства от родительской области.

  - Области создают контекст в котором вычисляются выражения. Например, {@link guide/expression выражение} `{{username}}` не имеет смысла, если оно не вычислено в области, определяющей переменную `username`.

## Область как модель данных

Область является связующим звеном между контроллером и представлением. В фазе {@link compiler линковки} шаблона,
{@link api/ng.$compileProvider#directive директивы} привязывают выражения из  
{@link api/ng.$rootScope.Scope#$watch `$watch`} к области видимости. `$watch` позволяет уведомлять директивы 
об изменении свойства, что позволяет директиве обновить значение в DOM.

Контроллеры и директивы имеют ссылки на область, но не друг на друга. Это изолирует контроллер от директивы, 
а также от DOM'а. Это важный момент, так как контроллеры остаются визуально независимыми, что значительно
улучшает тестирование.

<example>
  <file name="script.js">
    function MyController($scope) {
      $scope.username = 'World';

      $scope.sayHello = function() {
        $scope.greeting = 'Hello ' + $scope.username + '!';
      };
    }
  </file>
  <file name="index.html">
    <div ng-controller="MyController">
      Your name:
        <input type="text" ng-model="username">
        <button ng-click='sayHello()'>greet</button>
      <hr>
      {{greeting}}
    </div>
  </file>
</example>

В приведенном выше примере `MyController` записывает в свойство `username` из области видимости
значение `World`. Область видимости затем обновляет значение в `input`, которое затем отображает поле ввода 
с предварительно заполненным именем пользователя. Это демонстрирует то, как контроллер может записать данные 
в область видимости.

Точно так же контроллер может назначить методы области видимости, как видно по методу `SayHello`, который 
вызывается, когда пользователь нажимает на кнопку «greet». Метод `SayHello` может прочитать свойство `username` 
и создать свойство `greeting`. Это показывает, что свойства в области видимости обновляются автоматически, 
когда они связаны с полями ввода HTML.

Логический рендеринг `{{greeting}}` включает в себя:

  * вычисление области видимости, связанной с DOM-узлом, где выражение `{{greeting}}` определено в шаблоне. 
    В данном примере это та же область видимости, что и область, переданная в `MyController`. (Иерархию 
    областей видимости рассмотрим позже.)

  * Вычисление выражения `greeting` в области видимости, объявленной выше, и присвоение результата тексту, 
    включенному в элемент DOM.


Можно думать об области видимости и ее свойствах, как о данных, которые используются для визуализации представления. 
Область видимости является единственным источником актуальных данных для всех вещей, связанных с представлением.

С точки зрения тестируемости, разделение вида и контроллера желательно, потому что это позволяет протестировать 
поведение, не отвлекаясь на детали рендеринга.

<pre>
  it('should say hello', function() {
    var scopeMock = {};
    var cntl = new MyController(scopeMock);

    // Утверждение, что имя пользователя является предварительно-заполняемым
    expect(scopeMock.username).toEqual('World');

    // Утверждение, что мы читаем имя пользователя и приветствуем его
    scopeMock.username = 'angular';
    scopeMock.sayHello();
    expect(scopeMock.greeting).toEqual('Hello angular!');
  });
</pre>


## Иерархия областей видимости

Каждое приложение Angular имеет только одну корневую область видимости, но может иметь так же несколько дочерних 
областей.

Приложение может иметь несколько областей видимости, потому что некоторые {@link guide/directive директивы} 
создают новых потомков областей (см. директивы в документации по API, чтобы узнать, какие из них создают новые 
области видимости). После создания новых областей они будут добавлены как потомки их родительской области. 
Это создает древовидную структуру, параллельную структуре DOM, к которой они прикреплены

Когда Angular вычисляет выражение `{{username}}`, то сначала ищет в области видимости, связанной с данным элементом,
свойство `username`. Если такое свойство не найдено, он ищет в родительской области и так далее, пока не достигнет 
корневой области видимости. В JavaScript такое поведение называется прототипным наследованием и дочерние области 
прототипически наследуются от своих родителей.

Этот пример иллюстрирует области видимости в приложении и прототипное наследование свойств.

<example>
  <file name="style.css">
    /* remove .doc-example-live in jsfiddle */
    .doc-example-live .ng-scope {
      border: 1px dashed red;
    }
  </file>
  <file name="script.js">
    function EmployeeController($scope) {
      $scope.department = 'Engineering';
      $scope.employee = {
        name: 'Joe the Manager',
        reports: [
          {name: 'John Smith'},
          {name: 'Mary Run'}
        ]
      };
    }
  </file>
  <file name="index.html">
    <div ng-controller="EmployeeController">
      Manager: {{employee.name}} [ {{department}} ]<br>
      Reports:
        <ul>
          <li ng-repeat="employee in employee.reports">
            {{employee.name}} [ {{department}} ]
          </li>
        </ul>
      <hr>
      {{greeting}}
    </div>
  </file>
</example>

Обратите внимание, что Angular автоматически помечает классом `ng-scope` элементы прикрепленные к области видимости. 
Определение `<style>` в данном примере подсвечивает красным новые области. Дочерние области видимости необходимы, 
чтобы повторитель вычислил выражение `{{employee.name}}`, но в зависимости от области видимости выражение может 
иметь другой результат. Аналогично вычисление `{{department}}` прототипически наследуется от корневой области 
видимости, так как это единственное место, где `department` определен.


## Извлечение областей видимости из DOM.

Области видимости крепятся к DOM как данные свойства `$scope`, и могут быть получены в целях отладки. 
(Маловероятно, что возникнет необходимость получения областей видимости таким образом внутри приложения.) Место, 
где корневая область видимости крепится к DOM определяется расположением директивы 
{@link api/ng.directive:ngApp `ng-app`}. Обычно `ng-app` помечается элемент `<html>`, но ею может быть обозначен
и другой элемент, если, например, Angular должен контроллировать только часть вида.

Чтобы посмотреть области видимости в отладчике:

  1. Щелкните правой кнопкой мыши на интересующем элементе в вашем браузере и выберите «проверить элемент». 
     Должен показаться браузерный отладчик с выделенным элементом на который вы нажали.

  2. Отладчик позволяет получить доступ к выбранному элементу в консоли как к переменной `$0`

  3. Чтобы прочитать соответствующую область видимости выполните в консоли: `angular.element($0).scope()`


## Распределение событий областей видимости

Области могут распространяться в событиях аналогично событиям DOM. Событие можно
{@link api/ng.$rootScope.Scope#$broadcast транслировать} в дочернюю область видимости или 
{@link api/ng.$rootScope.Scope#$emit генерировать} в родительских

<example>
  <file name="script.js">
    function EventController($scope) {
      $scope.count = 0;
      $scope.$on('MyEvent', function() {
        $scope.count++;
      });
    }
  </file>
  <file name="index.html">
    <div ng-controller="EventController">
      Root scope <tt>MyEvent</tt> count: {{count}}
      <ul>
        <li ng-repeat="i in [1]" ng-controller="EventController">
          <button ng-click="$emit('MyEvent')">$emit('MyEvent')</button>
          <button ng-click="$broadcast('MyEvent')">$broadcast('MyEvent')</button>
          <br>
          Middle scope <tt>MyEvent</tt> count: {{count}}
          <ul>
            <li ng-repeat="item in [1, 2]" ng-controller="EventController">
              Leaf scope <tt>MyEvent</tt> count: {{count}}
            </li>
          </ul>
        </li>
      </ul>
    </div>
  </file>
</example>



## Жизненный цикл области видимости

Нормальный поток исполнения в рамках выполнения обработчиков событий - это исполнение соответствующих колбэков
JavaScript. После каждого выполнения колбэка, браузер перерисовывает DOM и возвращается обратно к отслеживанию событий.

Когда браузер вызывает JavaScript код, тот выполняется вне контекста Angular, и это означает что Angular ничего 
не знает об изменении модели. Для правильной обработки изменения модели, поток выполнения должен войти в контекст 
Angular, выполнив вызов {@link api/ng.$rootScope.Scope#$apply `$apply`}. Только те изменения модели, которые 
выполняются внутри вызова `$apply()` будут правильно обработаны Angular. Например, если директива отслеживает 
события DOM, такие как {@link api/ng.directive:ngClick `ng-click`}, они должны быть выполнены внутри метода $apply().

После вычисления выражения, вызов `$apply()` выполняет цикл {@link api/ng.$rootScope.Scope#$digest `$digest`}. 
В этой фазе область видимости просматривает все выражения в `$watch` и сравнивает их с предыдущим значением. 
Проверка на изменения выполняется асинхронно. Это означает, что такое присваивание как 
`$scope.username="angular"` не приведет к немедленному оповещению списка `$watch` об изменениях. Вместо этого, 
оповещение списка $watch откладывается до обработки цикла `$digest`. Это отложенное оповещение необходимо, 
поскольку позволяет объединить несколько обновлений модели в одно оповещение $watch, а также гарантирует, что 
во время процедуры очередного оповещения `$watch` никаких других функций `$watch` не выполняется. Если `$watch` 
меняет значение в модели, это вызывает дополнительную итерацию цикла `$digest`. 

  1. **Создание**

     {@link api/ng.$rootScope Корневая область видимости} создается во время выполнения фазы загрузки приложения
     инжектором ({@link api/AUTO.$injector $injector}). Во время связывания шаблона, некоторые директивы также 
     создают новые дочерние области видимости. 

  2. **Регистрация наблюдателя**

     Во время связывания шаблона директивы регистрируют {@link api/ng.$rootScope.Scope#$watch наблюдателей} 
     в области видимости. Эти наблюдатели будут использованы для синхронизации значений в модели с данными в DOM.

  3. **Изменение модели**

     Для правильной обработки изменений вы должны делать их только внутри вызова
     {@link api/ng.$rootScope.Scope#$apply scope.$apply()}. Angular API делает это неявно, и таким образом 
     никаких дополнительных вызовов `$apply` не нужно во время выполнения синхронных вызовов в контроллерах 
     или асинхронных вызовах в сервисах {@link api/ng.$http $http} или {@link api/ng.$timeout $timeout}.

  4. **Наблюдение за изменениями**

     В конце вызова `$apply`, Angular выполняет цикл {@link api/ng.$rootScope.Scope#$digest $digest} в корневой 
     области видимости, который распространяется также на дочерние области видимости. Во время выполнения цикла 
     `$digest` все выражения или функции в списке `$watched` проверяются с целью выявления изменения модели и если 
     такое изменение зафиксировано - вызывается соответствующий обработчик в `$watch`.

  5. **Разрушение области видимости**

     Когда дочерние области видимости более не нужны, вызывается создатель области видимости, который также 
     отвечает и за удаление ее через API {@link api/ng.$rootScope.Scope#$destroy scope.$destroy()}. Это 
     остановит распространение вызовов `$digest` в дочерние области видимости и позволит сборщику мусора освободить 
     используемую память. 


### Области видимости и директивы

Во время фазы компиляции, {@link compiler компилятор} находит {@link api/ng.$compileProvider#directive директивы} 
в шаблоне DOM. Такие директивы обычно делятся на две категории:

  - {@link api/ng.$compileProvider#directive Директивы} наблюдения, такие как заключенные в двойные фигурные скобки 
    выражения типа `{{expression}}`, которые регистрируют свои функции-наблюдатели вызовом метода 
    {@link api/ng.$rootScope.Scope#$watch $watch()}. Этот тип директив необходим для обеспечения оповещения 
    об изменениях которые могут привести к обновлению представления.

  - Директивы прослушивания, такие как {@link api/ng.directive:ngClick ng-click}, которые регистрируют 
    соответствующую функцию в DOM, которая выполняет соответствующее ей выражение и обновляет представление, 
    используя метод {@link api/ng.$rootScope.Scope#$apply $apply()}.

Когда вызывается внешнее событие (такое как действие пользователя, таймер или XHR), ассоциированное
с ним выражение должно быть выполнено в соответствующей области видимости посредством вызова метода 
{@link api/ng.$rootScope.Scope#$apply $apply()}, и таким образом все обработчики, отслеживающие события,
выполняются корректно.

### Директивы, создающие области видимости

В большинстве случаев, {@link api/ng.$compileProvider#directive директивы} и области видимости взаимодействуют,
но не создают при этом новых областей видимости. Однако, некоторые директивы, такие как 
{@link pi/ng.directive:ngController ng-controller} и {@link pi/ng.directive:ngRepeat ng-repeat}, создают новые 
дочерние области видимости и закрепляют их за соответствующими DOM элементами. Вы можете получить область
видимости для любого DOM элемента при помощи метода `angular.element(aDomElement).scope()`.

### Контролеры и области видимости

Контроллеры и области видимости взаимодействуют друг с другом в следующих ситуациях:

   - Контроллеры используют области видимости для предоставления методов шаблонам (см. 
     {@link api/ng.directive:ngController ng-controller}).

   - Контроллеры определяют методы (и, соответственно, поведение) которые могут изменять модель (свойства 
     в области видимости).

   - Контроллеры могут регистрировать {@link api/ng.$rootScope.Scope#$watch наблюдателей} в модели. Эти 
     наблюдатели выполняются сразу после обработки функций контроллера.

См. также {@link api/ng.directive:ngController ng-controller}


### Обсуждение производительности области видимости `$watch`

Грязная проверка (Dirty checking) области видимости для изменения свойств является распространенной операцией 
в Angular и по этой причине функция проверки должна быть эффективной. Следует позаботиться о том, что бы функция 
проверки не обращалась к DOM, т. к. доступ к DOM на несколько порядков медленнее, чем доступ к свойствам
JavaScript-объектов.

