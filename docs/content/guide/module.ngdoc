@ngdoc overview
@name Developer Guide: Модули
@description

# Что такое модуль?

В большинстве приложений есть главный метод, который создает экземпляр, связывает и загружает приложение. Приложения в Angular не имеют главного исполняемого метода. Модуль выполняет роль декларативного описания того, как приложение должно быть загружено. Есть несколько преимуществ такого подхода:

  * Процесс более декларативен и прост для понимания
  * Для модульного тестирования нет необходимости загружать все модули, использующиеся в написании модульных тестов.
  * Можно подгрузить дополнительные модули, которые переопределят какие-то настройки, облегчая тем самым комплексное
    (end-to-end) тестирование
  * Сторонний код можно упаковать в модуль и использовать многократно.
  * Модули могут быть загружены в произвольном порядке/параллельно (в связи с отсрочкой их выполнения).


# Основы

Идем дальше. Как нам создать приложение, выводящее Hello World?

Важные вещи:

  * API {@link api/angular.Module модуля}
  * Обратите внимание на ссылку на модуль `myApp` в `<html ng-app="myApp">`, это то, что загрузит приложение, с помощью вашего модуля.

<doc:example module='myApp'>
  <doc:source>
    <script>
      // объявление модуля
      var myAppModule = angular.module('myApp', []);

      // настройка модуля.
      // в примере мы создаем приветственный фильтр
      myAppModule.filter('greet', function() {
       return function(name) {
          return 'Hello, ' + name + '!';
        };
      });

    </script>
    <div>
      {{ 'World' | greet }}
    </div>
  </doc:source>
</doc:example>



# Рекомендуемая установка

Приведенный выше пример достаточно прост и плохо подходит для сложных приложений. Вместо этого мы рекомендуем вам разбить приложение на несколько модулей, например так:

  * Сервисный модуль для описания сервисов
  * Директивный модуль для описания директив
  * Фильтрующий модуль для описания фильтров
  * И модуль всего приложения, который зависит от вышеуказанных модулей и содержит код инициализации.

Причина такого разделения в том, что в тестах зачастую необходимо проигнорировать код инициализации, 
который, как правило, трудно проверить. Выделив этот код в отдельный модуль, его можно легко убрать из тестов. 
Так же тестирование станет более сфокусированным только на те модули, которые имеют отношения к тестам.

Сказанное выше является лишь предложением, поэтому не стесняйтесь адаптировать это к собственным потребностям.

<doc:example module='xmpl'>
  <doc:source>
    <script>
      angular.module('xmpl.service', []).
        value('greeter', {
          salutation: 'Hello',
          localize: function(localization) {
            this.salutation = localization.salutation;
          },
          greet: function(name) {
            return this.salutation + ' ' + name + '!';
          }
        }).
        value('user', {
          load: function(name) {
            this.name = name;
          }
        });

      angular.module('xmpl.directive', []);

      angular.module('xmpl.filter', []);

      angular.module('xmpl', ['xmpl.service', 'xmpl.directive', 'xmpl.filter']).
        run(function(greeter, user) {
          // Это, в сущности, часть с кодом основного метода
          greeter.localize({
            salutation: 'Bonjour'
          });
          user.load('World');
        })


      // Контроллер приложения
      var XmplController = function($scope, greeter, user) {
        $scope.greeting = greeter.greet(user.name);
      }
    </script>
    <div ng-controller="XmplController">
      {{ greeting }}!
    </div>
  </doc:source>
 </doc:example>



# Модуль загрузки и зависимостей

Модуль представляет собой набор конфигурационных и исполняемых блоков, которые применяются к приложению в процессе 
загрузки. В своей простейшей форме модуль состоит из двух видов блоков:

  1. **Конфигурационные блоки** - выполняются в фазе регистрации и конфигурации. Только источники и константы 
     могут быть внедрены в конфигурационные блоки. Это сделано для предотвращения случайного создания 
     экземпляров сервисов, до их окончательной настройки.
  2. **Исполняемые блоки** - выполняются после того как инжектор создаст и запустит приложение. Только экземпляры 
     и константы могут быть введены в исполняемые блоки. Это необходимо для предотвращения дальнейшей настройки 
     системы во время работы приложения.

<pre>
angular.module('myModule', []).
  config(function(injectables) { // provider-injector
    // Пример конфигурационного блока.
    // Их может быть сколько угодно.
    // Можно внедрять только источники (не экземпляры)
    // внутрь конфигурационного блока.
  }).
  run(function(injectables) { // instance-injector
    // Пример исполняемого блока.
    // Их может быть сколько угодно.
    // Можно внедрять только экземпляры (не источники)
    // внутрь исполняемого блока
  });
</pre>

## Конфигурационные блоки

Некоторые удобные методы модуля, эквивалентные конфигурации блока. Например:

<pre>
angular.module('myModule', []).
  value('a', 123).
  factory('a', function() { return 123; }).
  directive('directiveName', ...).
  filter('filterName', ...);

// а так же

angular.module('myModule', []).
  config(function($provide, $compileProvider, $filterProvider) {
    $provide.value('a', 123);
    $provide.factory('a', function() { return 123; });
    $compileProvider.directive('directiveName', ...);
    $filterProvider.register('filterName', ...);
  });
</pre>

Конфигурационные блоки применяются в том порядке, в котором они зарегистрированы. Единственным исключением из этого 
являются предопределенные константы, которые размещены в начале всех конфигурационных блоков.

## Исполняемые блоки

Исполняемые блоки ближе всего к главному методу Angular. Исполняемый блок содержит код, который должен выполниться 
при запуске приложения. Он выполняется после того, как все службы настроены и создан инжектор. Исполняемые блоки 
обычно содержат код, усложняющий модульное тестирование, и по этой причине должны быть объявлены в изолированных 
модулях, так чтобы их можно было исключить из модульных тестов.

## Зависимости

Одни модули могут зависеть от других модулей. Зависимость от модуля означает, что необходимый модуль должен быть 
загружен перед требующим его загрузки модулем. Другими словами, настройку блоков с необходимыми модулями нужно 
выполнить до настройки блоков которым требуются эти модули. То же самое верно и для исполняемых блоков. Каждый 
модуль может быть загружен только один раз, даже если он требуется для нескольких других модулей.

## Асинхронная загрузка

Модули это способ управления настройкой инжектора $injector, и не имеют ничего общего с загрузкой скриптов в VM. 
Существуют проекты, подгружающие необходимые скрипты извне, что может быть сделано и в Angular. Поскольку модули 
ничего не делают во время загрузки они могут быть загружены в VM в любом порядке и таким образом загрузчики скрипта 
могут воспользоваться этим свойством и распараллелить процесс загрузки.


# Модульное тестирование

В простейшей форме модульное тестирование это выделение части из приложения и моделирование воздействий на эту 
часть. Важно понимать, что каждый модуль может быть загружен в инжектор только один раз. Обычно приложение имеет 
только один инжектор. Но в тестах, каждый тест имеет свой собственный инжектор, это означает, что модули загружаются 
несколько раз в VM. Правильно структурированные модули могут помочь провести модульное тестирование, как в этом 
примере:

Во всех примерах будем считать определение модуля таким:
<pre>
  angular.module('greetMod', []).

    factory('alert', function($window) {
      return function(text) {
        $window.alert(text);
      }
    }).

    value('salutation', 'Hello').

    factory('greet', function(alert, salutation) {
      return function(name) {
        alert(salutation + ' ' + name + '!');
      }
    });
</pre>

Напишем несколько тестов:
<pre>
describe('myApp', function() {
  // Загружаем соответствующие модули приложения затем загружаем
  // специальный тестовый модуль, который перекрывает $window фиктивной версией,
  // так что вызов window.alert () не будет блокировать тест
  // выполняющийся с окном предупреждения.  Это пример переопределения
  // конфигурации в тестах.
  beforeEach(module('greetMod', function($provide) {
    $provide.value('$window', {
      alert: jasmine.createSpy('alert')
    });
  }));

  // Функция inject() создаст инжектор, внедрив все что нужно,
  // и $window в тестах. Тесты не должны самостоятельно решать проблемы
  // со связями в приложении, только если тестируют их.
  it('should alert on $window', inject(function(greet, $window) {
    greet('World');
    expect($window.alert).toHaveBeenCalledWith('Hello World!');
  }));

  // другой способ переопределения конфигурации в
  // тестах использующих встроенный модуль и внедрение методов.
  it('should alert using the alert service', function() {
    var alertSpy = jasmine.createSpy('alert');
    module(function($provide) {
      $provide.value('alert', alertSpy);
    });
    inject(function(greet) {
      greet('World');
      expect(alertSpy).toHaveBeenCalledWith('Hello World!');
    });
  });
});
</pre>
