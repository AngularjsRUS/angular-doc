@ngdoc overview
@name Tutorial: 3 - Поиск и фильтрация
@description

<ul doc-tutorial-nav="3"></ul>


В предыдущем шаге, мы с вами проделали большую работу, создав основу для приложения. Теперь мы попробуем сделать
что-то простое. Давайте добавим полнотекстовый поиск (full text search). Да, это будет просто! Также мы продолжим
писать тесты и напишем тесты для системного тестирования (end-to-end test). Cистемные тесты являются вашими
хорошими друзьями. Они живут с вашим приложением, следят за ним и быстро обнаруживают регрессию.


<div class="tabbable" show="true">

  <div class="tab-pane well" id="git-mac" title="Git на Mac/Linux" value="gitUnix">
    <ol>
      <li>
        <p>Откатите ваш рабочий код до шага 3.</p>
        <pre>git checkout -f step-3</pre>
      </li>
      <li>
        <p>Перезагрузите страницу или проверьте приложение на 
           <a href="http://angular.github.com/angular-phonecat/step-3/app">сервере Angular</a>.
        </p>
      </li>
    </ol>
  </div>
  
  <div class="tab-pane well" title="Git на Windows" value="gitWin">
    <ol>
      <li>
        <p>Откатите ваш рабочий код до шага 3.</p>
        <pre>git checkout -f step-3</pre>
      </li>
      <li>
        <p>Перезагрузите страницу или проверьте приложение на 
           <a href="http://angular.github.com/angular-phonecat/step-3/app">сервере Angular</a>.
        </p>
      </li>
    </ol>
  </div>
  
</div>


Теперь приложение имеет окно для поиска (search box). Обратите внимание, что список телефонов на странице меняется 
в зависимости от того, что пользователь вводит в окно поиска.

Наиболее важные изменения между шагом 2 и текущим шагом (шагом 3) перечислены ниже. Вы можете увидеть полный список 
изменений перейдя по ссылке {@link https://github.com/angular/angular-phonecat/compare/step-2...step-3 GitHub}:


## Контроллер

Нам не потребовалось вносить изменения в контроллер.


## Шаблон

__`app/index.html`:__
<pre>
  <div class="container-fluid">
    <div class="row-fluid">
      <div class="span2">
        <!--Sidebar content-->

        Search: <input ng-model="query">

      </div>
      <div class="span10">
        <!--Body content-->

        <ul class="phones">
          <li ng-repeat="phone in phones | filter:query">
            {{phone.name}}
            <p>{{phone.snippet}}</p>
          </li>
        </ul>

      </div>
    </div>
  </div>
</pre>

Мы добавили стандартный HTML тег `<input>` и воспользовались магией Angular-а, а именно функцией 
{@link api/ng.filter:filter $filter}, которая обрабатывает входные данные для директивы
{@link api/ng.directive:ngRepeat ngRepeat}.

Это позволяет пользователю вводить критерии поиска и сразу же видеть результат своего поиска по списку
телефонов. Этот новый код демонстрирует следующее:

* Cвязывание данных: Это одна из основных особенностей в Angular-е. При загрузке страницы, Angular связывает
  имя поля ввода с переменной, с таким же именем, в модели (data model) и синхронизирует их между собой.

  В этом коде, данные, которые пользователь вводит в поле ввода (с именем __`query`__) сразу же
  доступны как фильтр входных данных для списка повторителя (repeater) (`phone in phones | filter:`__`query`__).
  Когда изменяется модель (data model) это вызывает изменение входных данных для повторителя (repeater's input),
  повторитель обновляет DOM, чтобы отразить текущее состояние модели.

      <img  class="diagram" src="img/tutorial/tutorial_03.png">

* Использование `filter` фильтра: функция {@link api/ng.filter:filter Фильтр(filter) } использует значение
  переменной `query` для создания нового массива, который содержит только те записи, которые соответствуют `query`.

  `ngRepeat` автоматически обновляет представление (view) в ответ на изменение количества телефонов, которые
  возвращает фильтр `filter`. Процесс полностью прозрачен для разработчика.


## Тестирование

На шаге 2 мы узнали как написать и запустить модульные тесты (unit tests). Модульные тесты идеально подходят 
для тестирования контроллеров и других компонентов нашего приложения, написанных на JavaScript, но модульными тестами
не очень-то легко тестировать DOM-манипуляции или связи нашего приложения. Для этих целей системные тесты являются 
гораздо лучшим выбором.

Функция поиска была полностью реализована через шаблоны (templates) и связывание данных (data-binding), 
поэтому мы напишем наш первый системный тест, чтобы убедиться, что эта функция работает.

__`test/e2e/scenarios.js`:__
<pre>
describe('PhoneCat App', function() {

  describe('Phone list view', function() {

    beforeEach(function() {
      browser().navigateTo('../../app/index.html');
    });


    it('should filter the phone list as user types into the search box', function() {
      expect(repeater('.phones li').count()).toBe(3);

      input('query').enter('nexus');
      expect(repeater('.phones li').count()).toBe(1);

      input('query').enter('motorola');
      expect(repeater('.phones li').count()).toBe(2);
    });
  });
});
</pre>

Хотя синтаксис этого теста очень похож на модульный тест для нашего контроллера, написанный при помощи Jasmine, но
системный тест использует API из {@link guide/dev_guide.e2e-testing Angular E2E тестирования}.

Для запуска системного теста, откройте одну из следующих ссылок в новой вкладке браузера:

* для пользователей node.js: {@link http://localhost:8000/test/e2e/runner.html}
* для пользователей других http-серверов:
`http://localhost:[port-number]/[context-path]/test/e2e/runner.html`
* если вы просто читаете этот учебник: {@link http://angular.github.com/angular-phonecat/step-3/test/e2e/runner.html}

Ранее мы видели, как Karma-у можно использовать для выполнения модульных тестов. Кроме того, Karma-а так же может 
запускать системные тесты. Для этого можете воспользоваться скриптом `./scripts/e2e-test.sh`. 
Системные тесты медленные в отличие от модульных тестов. Karma будет завершаться (exit) после выполнения теста 
и автоматически не перезапускает набор тестов для каждого изменения файла. Чтобы снова запустить набор тестов, 
необходимо заново запустить скрипт `e2e-test.sh`.

Этот тест проверяет, что поле поиска и повторитель правильно соединены (wired) друг с другом. Обратите внимание, как
легко писать системные тесты в Angular-е. Хотя этот пример является простым тестом, он действительно легко 
переписывается на любой функционал и легко читаем.


# Давайте поэкспериментируем

* Отображение текущего значения `query` модели происходит путем добавления `{{query}}` связывания (binding) в
  `index.html` шаблоне. Посмотрите как меняется модель, когда вы что-нибудь вводите в поле ввода.

* Давайте посмотрим, как мы можем получить текущее значение `query` модели и отобразить ее 
  в заголовке (title) HTML-страницы.

  Вы могли бы подумать, что нужно просто добавить {{query}} в title тег следующим образом:

          <title>Google Phone Gallery: {{query}}</title>

  Однако, когда вы перезагрузите страницу, вы не увидите ожидаемого результата. Это происходит потому, 
  что `query` модель живет в областе видимости (scope), определенной body элементом:

          <body ng-controller="PhoneListCtrl">

  Если вы хотите связать `query` модель с `<title>` элементом, вы должны __переместить__ объявление
  `ngController` в html элемент, потому что он является общим родителем для body и title элементов:

          <html ng-app="phonecatApp" ng-controller="PhoneListCtrl">

  Обязательно __удалите__ декларацию `ng-controller` из body элемента.

  Использование двойных фигурных скобок хорошо работает в title элементе, но вы могли заметить, что на самом деле,
  фигурные скобоки на долю секунды отображаются пользователю при загрузке страницы. Лучшим решением было 
  бы использовать {@link api/ng.directive:ngBind ngBind} или {@link api/ng.directive:ngBindTemplate
ngBindTemplate} директивы, которые невидимы для пользователя при загрузке страницы:

          <title ng-bind-template="Google Phone Gallery: {{query}}">Google Phone Gallery</title>

* Добавьте следующий код в блоке `describe`, системного теста `test/e2e/scenarios.js`:

  <pre>
    it('should display the current filter value within an element with id "status"',
        function() {
      expect(element('#status').text()).toMatch(/Current filter: \s*$/);

      input('query').enter('nexus');

      expect(element('#status').text()).toMatch(/Current filter: nexus\s*$/);

      //альтернативный вариант последнего утверждения (assertion), которое проверяет является ли значение связанным
      using('#status').expect(binding('query')).toBe('nexus');
    });
  </pre>

  Обновите вкладку браузера с запущенным системным тестом, чтобы увидеть, что тест не проходит. Для того, чтобы тест
  прошел, отредактируем шаблон `index.html`, добавив `div` или `p` элемент с `id` `"status"`, содержащий
  переменную `query` и текст "Current filter:". Например:

          <div id="status">Current filter: {{query}}</div>

* Добавьте оператор `pause()` внутри системного теста и перезапуститe тест. Вы увидите, что возникнет пауза.
  Это дает вам возможность исследовать состояние приложения в тот момент, когда оно отображается в браузере. 
  Приложение работает! Вы можете изменить поисковый запрос, чтобы убедиться в этом. Обратите внимание, насколько 
  полезно это для устранения неполадок системных тестов.


# Идем дальше

Вот мы и добавили полнотекстовый поиск и тест, чтобы убедиться, что поиск работает! Теперь можем идти дальше
на {@link step_04 Шаг 4}, чтобы узнать как добавить возможность сортировки телефонов в приложение.


<ul doc-tutorial-nav="3"></ul>

