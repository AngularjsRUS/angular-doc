@ngdoc overview
@name FAQ
@description

#FAQ

## Вопросы

### Почему этот проект называется «AngularJS»? Почему пространство имен названо «ng»?

Потому что HTML имеет угловые скобки и «ng» звучит как «угловатый».


### Является ли AngularJS библиотекой, фреймворком, плагином или расширением для браузера?

AngularJS лучше подходит под определение фреймворка, хотя он гораздо легче, чем типичный фреймворк, и именно поэтому многие путают его с библиотекой.

AngularJS на 100% JavaScript, 100% на стороне клиента и совместим с настольными и мобильными браузерами.
Так что это определенно не плагин или другое родное расширение браузера.


### AngularJS это шаблонизатор?

Свысока Angular выглядит просто как еще один шаблонизатор. Но есть одна
важная причина, из-за которой Angular отличается от шаблонизаторов, что делает его пригодным для
разработки приложений: двунаправленное связывание данных. Шаблон скомпилирован в браузере и
этап компиляции производит в живом виде. Это означает, что вам, как разработчику, не нужно писать
код, который постоянно синхронизирует вид с моделью и модель с видом, как в других шаблонизаторах.


### Нужно ли беспокоиться по поводу дыры в безопасности в AngularJS?

Как и любая другая технология, AngularJS проницаем для атак. Angular, тем не менее, обеспечивают
встроенную защиту от основных дыр в безопасности, в том числе от межсайтового скриптинга и HTML инъекций. 
AngularJS делает круговое скрытие для всех строк и даже предлагает XSRF защиту для связи с сервером.

AngularJS был разработан, чтобы быть совместимым с другими мерами безопасности, как политика безопасности содержания
(CSP), HTTPS (SSL/TLS) и серверная аутентификация и авторизация, которые серьезно препятствуют возможным атакам, 
и мы настоятельно рекомендуем их использование.


### Могу ли я скачать исходные коды, сборки и хосты AngularJS среды на свой компьютер?

Да. Смотрите инструкции в разделе {@link downloading загрузка}.


### В каких браузерах работает Angular?

Мы запускаем наш обширный набор тестов в следующих браузерах: Safari, Chrome, Firefox, Opera,
IE8, IE9 и мобильные браузеры (Android, Chrome Mobile, IOS Safari). См. {@link guide/ie Совместимость с Internet 
Explorer} для более подробной информации о поддержке старых версий IE.


### Насколько быстр Angular?

Время запуска во многом зависит от скорости интернета, состояния кэша, используемого браузера и
задействованного оборудования, но обычно мы измеряем время загрузки десятками или сотнями миллисекунд.

Производительность среды исполнения может изменяться в зависимости от количества и сложности связывания на странице
, а также от скорости сервера (для приложений, которые запрашивают данные у сервера). Только для
иллюстрации мы обычно быстро строим приложения с сотнями или тысячами активных привязок.

### Насколько велик файл angular.js, который необходимо подключить?

Размер сжатого и минифицированного файла меньше 29 КБ.


### Могу ля я использовать Closure Library с открытым кодом в Angular?

Да, вы можете использовать виджеты из {@link http://code.google.com/closure/library Closure Library}
в Angular.


### Использует ли Angular jQuery?

Да, Angular может использовать библиотеку {@link http://jquery.com/ jQuery}, если она используется в приложении и 
загружается до Angular. Если JQuery нет по адресу, указанному в скрипте, Angular откатывается до собственной 
реализации JQuery, которую мы называем {@link api/angular.element  jQLite}.


### Какова тестируемость Angular?

Очень тестируем и проработан в этом плане от начала до конца. Имеет встроенный механизм внедрения зависимости 
framework, поддерживает имитацию (mock) для большинства тяжелых зависимостей (серверной коммуникации). См. так же
{@link api/ng сервис}.


### Как узнать больше об Angular?

Смотрите рассказ от 17 июля 2012
"{@link http://www.youtube.com/watch?v=1CpiB3Wk25U AngularJS Intro + Dependency Injection}".


### Под какой лицензией распространяется Angular?

Лицензия MIT.

### Могу ли я загрузить и использовать логотип Angular?

Да! Вы можете найти файлы проекта в нашем репозитории на GitHub в разделе 
"{@link https://github.com/angular/angular.js/tree/master/images/logo angular.js/images/logo}" 
Дизайн логотипа под лицензией 
"{@link http://creativecommons.org/licenses/by-sa/3.0/ Creative Commons Attribution-ShareAlike 3.0 Unported License}". 
Если хотите использовать по-другому, свяжитесь с нами.


### Как получить символику AngularJS?

Мы часто приносим несколько футболок и наклеек на мероприятия, где выступаем. Если хотите заказать для себя, то 
люди, которые их производят с удовольствием сделают для вас по существующим шаблонам любое количество.

**Наклейки**
Свяжитесь с Томом Виттингом (или кем-нибудь по продаже) по электронной почте tom@stickergiant.com, и скажите ему, 
что хотите заказать наклейки с AngularJS, такие же как в работе № 42711. Нужно будет предоставить информацию для 
выставления счета и доставки.

Пока дизайн остается точно таким же, {@link http://www.stickergiant.com StickerGiant} даст скидку на повторный заказ.

**Футболки**
Свяжитесь с {@link http://www.customink.com www.customink.com} и скажите, что хотите футболку с дизайном «angularjs»,
так же как и в прошлом заказе #2106371. Нужно будет предоставить информацию для выставления счета и доставки.

Пока дизайн остается неизменным, вы получите скидку как за повторный заказ.


## Распространенные ошибки

Служба поддержки канала Angular (# angularjs на Freenode) укажет на повторяющиеся ошибки, которые допускают новички. 
Цель данного документа — указать на них, прежде чем вы обнаружите их на своей шкуре.


### DOM-манипуляции

Перестаньте пытаться использовать jQuery для изменения DOM в контроллерах. Серьезно.
Включая добавление, удаление элементов, извлечение их содержимого, показ и скрытие.
Используйте встроенные директивы, или напишите собственные, если необходимо, чтобы проделывать DOM-манипуляции.
См. ниже о дублировании функциональности.

Чтобы избавиться от этой привычки, рассмотрите возможность исключения jQuery из вашего приложения.
Серьезно. В Angular встроен сервис $http и мощные директивы, которые делают его почти всегда ненужным.
Во встроенном jQLite есть несколько особенностей наиболее часто используемых при написании директив, 
особенно связи с событиями.

### Попытка дублирования существующей функциональности

То, что ваше приложение не требуют вначале определенной функциональности — хорошая практика.
В Angular есть несколько штук, которые вероятно изменят старые привычки.

**ng-repeat**

Люди пытаются использовать jQuery (см. выше), чтобы добавить несколько элементов в некоторый контейнер, после 
получения их с сервера. 
Фу! плохая собака! 
Это как раз то, для чего нужен `ng-repeat`, и он делает свою работу очень хорошо.
Храните данные с сервера в виде массива в `$scope`, и привяжите его к DOM с помощью `ng-repeat`.

**ng-show**

`ng-show` используется наиболее часто.
Показ и скрытия элементов по условию, используя jQuery распространенный прием в других приложениях, но в Angular 
есть способ лучше. 
`ng-show` (и `ng-hide`) показывает и скрывает элементы на основе логических выражений.
Опишите условия для показа и скрытия элемента в зависимости от переменных `$scope`:

    <div ng-show="!loggedIn">Нажмите <a href="#/login">сюда</a> чтобы войти</div>

Обратите также внимание на сопутствующие `ng-hide` и `ng-disabled`. 
Отметим особенно мощный `ng-switch`, который стоит использовать вместо нескольких взаимоисключающих `ng-show`.

**ng-class**

`ng-class` последний из большой тройки.
Применение классов к элементам — другая вещь, которая делается с помощью jQuery.
в Angular, конечно всё лучше.
Можно задать в `ng-class` имен классов, разделенных пробелами, а затем использовать как обычный класс `class`.
Это не очень интересно, поэтому есть второй синтаксис:

    <div ng-class="{ errorClass: isError, warningClass: isWarning, okClass: !isError && !isWarning }">...</div>

Где `ng-class` представляет собой объект, ключами которого являются имена CSS-классов, чьи значения зависят от 
выражения, использующего переменные в `$scope`. Элемент будет иметь все классы, установленные true, и ни один из тех, 
чье условие false.

Отметим также `ng-class-even` и `ng-class-odd`, и связанный с ними, хотя и несколько отличающийся, `ng-style`.


### `$watch` и `$apply`

Двухстороннее связывание данных это суть всего потрясающего в Angular.
Тем не менее, это не магия и есть некоторые ситуации, когда необходимо дать фреймворку толчок в правильном направлении.

При связывании значений с элементами в Angular с помощью `ng-model`, `ng-repeat` и т.д. Angular создает наблюдателя 
`$watch` для этого значения. Тогда всякий раз, когда значение из области видимости изменяется, все `$watch` 
замечают, что элемент выполнялся и обновляют всё остальное.

Иногда, как правило, когда вы создаете пользовательские директивы, приходится определять собственный `$watch` в 
области видимости значения, чтобы директива стала реагировать на изменения.

С другой стороны, иногда вы изменяете значение в области видимости в некотором коде, но приложение не реагирует на это.
Angular проверяет изменения переменной в области видимости после того как ваш код завершит работу, например, когда 
`ng-click` вызывает функцию в области видимости, Angular проверит изменения и среагирует.
Тем не менее, некоторый код находится вне  Angular и придется самостоятельно вызвать метод `scope.$apply()`, 
чтобы произвести обновление. Чаще всего это требуется в обработчиках событий в пользовательских директивах.


### Взаимодействие `ng-repeat` с другими директивами

`ng-repeat` чрезвычайно полезная и одна из самых мощных директивы в Angular.
Однако преобразование применительно к DOM является существенным.
Поэтому применение других директив (таких как `ng-show`, `ng-controller` и др.) к тому же элементу, что и `ng-repeat`, 
как правило, приводит к проблемам.

Если необходимо применить директиву в целому набору, оберните набор в родительский элемент и примените директиву к нему.
Если необходимо применить директиву к каждому элементу набора, примените директиву к элементу с `ng-repeat`.


### `$rootScope` существует, но может создать проблемы

Области видимости в Angular составляют иерархию, прототипического наследования от корневой области в верхней 
части дерева. Как правило, это может быть проигнорировано, так как большинство видов имеют контроллер, и, 
следовательно, собственную область видимости.

Изредка встречаются фрагменты данных, которые необходимо сделать глобальным для всего приложения.
Их можно внедрить в `$rootScope` и задавать значения в ней как в любой другой области.
Поскольку области наследуются от корневой области, эти значения будут доступны для выражения прикрепленых 
к директивам, таким как `ng-show` так же как значения в локальной `$scope`.

Конечно, использовать глобальное состояние плохо, а потому стоит использовать `$rootScope` с умом, как вы бы (надеюсь) 
пользовались глобальными переменными в любом другом языке.
В частности, не используйте их для кода, только в данных.
Если будет желание вставить функцию на `$rootScope`, то почти всегда лучше поместить его в сервис, 
который может быть внедрен где это необходимо, и легко протестирован.

С другой стороны, не создавайте сервис, чья единственная цель хранение и возврат бита данных.
